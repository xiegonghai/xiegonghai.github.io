<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Xiegonghai's Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="while(question)just thinking;">
<meta property="og:type" content="website">
<meta property="og:title" content="Xiegonghai's Blog">
<meta property="og:url" content="https://yoursite.com/index.html">
<meta property="og:site_name" content="Xiegonghai's Blog">
<meta property="og:description" content="while(question)just thinking;">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Xiegonghai's Blog">
<meta name="twitter:description" content="while(question)just thinking;">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="https://yoursite.com/"/>

  <title> Xiegonghai's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Xiegonghai's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">梦想还是要有的</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="https://xiegonghai.github.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="https://xiegonghai.github.io/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="https://xiegonghai.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="https://xiegonghai.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/01/Docker制作hexo博客镜像/" itemprop="url">
                  Docker制作hexo博客镜像
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-01T10:01:59+00:00" content="2016-10-01">
              2016-10-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/10/01/Docker制作hexo博客镜像/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/01/Docker制作hexo博客镜像/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们知道docker是一种轻量级的虚拟化技术，而安装一个博客系统是一件繁琐的事情，需要安装和配置一系列的依赖包，以及修改相应的自己喜欢的样式，往往我们在特定的系统下安装好便一直使用，可是如果电脑坏了或者换电脑了，那重新搭建无疑是很费力不讨好的事情，如果新电脑是不同系统的话，为了做到一处安装处处使用的目的，我觉得尝试下docker技术，打算制作一个在linux下hexo博客的基础镜像，以后只要通过docker运行基础镜像便可以使用我搭建好的博客系统，无论我在哪里，只要拉取网盘镜像通过docker跑博客容器，那么便可以写博客并发布了</p>
<p>传统的虚拟机镜像安装一个ubuntu系统就十几个G，按docker官方仓库的ubuntu镜像也就一两百M，可以在这个基础上安装git,hexo,python,nodejs等,构建一个hexo博客系统可运行环境并保存相关镜像,这个大小相对虚拟机要小很多,而且容器可以很方便的和宿主机共享数据卷,我们可以在本地宿主机写相关博客，在docker博客容器内发布就可以了</p>
<h1 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h1><p>拉取linux基础镜像<br>基础容器内搭建hexo博客系统相关环境<br>保存修改后镜像<br>下面来介绍下相关技术以及流程：</p>
<h1 id="在基础容器内搭建自己的hexo博客并修改相关样式"><a href="#在基础容器内搭建自己的hexo博客并修改相关样式" class="headerlink" title="在基础容器内搭建自己的hexo博客并修改相关样式"></a>在基础容器内搭建自己的hexo博客并修改相关样式</h1><p>教程参看官方搭建文档 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">https://hexo.io/zh-cn/docs/</a><br>然后配置自己的hexo与github的连接<br>使得用hexo发布的时候可以发布到自己的github上<br>主要流程：<br>a.install git,安装详细下面介绍<br>记得本地秘钥加到github<br>b.在根目录<em>config.yml加上</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repository: git@github.com:xiegonghai/xiegonghai.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure></p>
<h1 id="linux安装git"><a href="#linux安装git" class="headerlink" title="linux安装git"></a>linux安装git</h1><p>1.安装git<br>apt-get install git<br>2.配置用户名密码<br>git config –global user.name = “”<br>git config –global user.email = “”<br>3.生成秘钥上传到github<br>ssh-keygen -C “emailAddress@gmail.com” -t rsa<br>将~/.ssh/id_rsa.pub内容加到github里<br>4.测试连通<br>ssh -v git@github.com</p>
<h1 id="docker-相关命令"><a href="#docker-相关命令" class="headerlink" title="docker 相关命令"></a>docker 相关命令</h1><p>0.安装docker<br>apt-get update<br>apt-get install -y docker.io<br>ln -sf /usr/bin/docker.io /usr/local/bin/docker<br>sed -i ‘$acomplete -F _docker docker’ /etc/bash_completion.d/docker.io<br>安装新版<br>apt-get install apt-transport-https<br>apt-key adv –keyserver hkp://keyserver.ubuntu.com:80 –recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9<br>sh -c “echo deb <a href="https://get.docker.io/ubuntu" target="_blank" rel="external">https://get.docker.io/ubuntu</a> docker main &gt; /etc/apt/sources.list.d/docker.list”<br>apt-get update<br>apt-get install lxc-docker<br>1.启动docker服务<br>service docker start<br>2.查看docker现有镜像(相当于查看有哪些源码)<br>docker images<br>3.查看在运行的容器有哪些(相当于查看有哪些进程)<br>docker ps -a<br>4.搜索共享仓库有哪些镜像<br>docker search centos<br>5.从registry.hub.docker.com拉取相关镜像<br>docker pull centos<br>6.保存镜像<br>docker save -o ubuntu_14.04.tar ubuntu:14.04<br>docker export 7691a814370e &gt;ubuntu.tar<br>7.载入镜像<br>docker load –input ubuntu_14.04.tar<br>docker load &lt; ubuntu_14.04.tar<br>docker import <a href="http://example.com/exampleimage.tgz" target="_blank" rel="external">http://example.com/exampleimage.tgz</a> example/imagerepo<br>cat ubuntu.tar | sudo docker import - test/ubuntu:v1.0<br>8.移除本地镜像<br>docker rmi training/sinatra<br>9.提交修改到容器<br>docker commit 614122caabb aoct/apache2<br>(容器id,目标镜像仓库,镜像名)<br>docker commit -m “” – “” id aoct/apache2<br>10.检查新创建的镜像的详细信息<br>docker inspect aoct/apache2<br>11.删除某个镜像<br>docker rm trusting_newron<br>12.停止或者重启某个容器<br>docker stop<br>docker restart<br>13.日志查看</p>
<p>docker logs instance_name<br>docker tag image_id repository:tag</p>
<p>14.运行一个容器<br>docker run -d ubuntu:14.04 /bin/sh -c “”</p>
<h3 id="挂载一个主机目录到容器的指定目录"><a href="#挂载一个主机目录到容器的指定目录" class="headerlink" title="挂载一个主机目录到容器的指定目录"></a>挂载一个主机目录到容器的指定目录</h3><p>docker run -d -P –name web -v /src/webapp:/opt/webapp training/webapp python  app.py<br>:ro设定为只读<br>docker run -d -P –name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py<br>挂载主机单个文件到容器<br>docker run -rm -it -v ~/.bash_history ubuntu /bin/bash</p>
<p>15.通过dockerfile来创建容器<br>新建一个目录,创建一个名为Dockerfile的文件<br>dockerfile 编写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">FROM ubuntu:14.04</div><div class="line">MAINTAINER 312182515@qq.com</div><div class="line">RUN apt-get update</div><div class="line">ENV LANG zh_CN.UTF-8</div><div class="line">ENV LC_ALL zh_CN.UTF-8</div></pre></td></tr></table></figure></p>
<p>命令构建容器<br>docker bulid -t =”ubuntu:hexo” .<br>-t里的为相应仓库和tag,.表示dockerfile所在目录</p>
<h1 id="docker-enter命令实现"><a href="#docker-enter命令实现" class="headerlink" title="docker-enter命令实现"></a>docker-enter命令实现</h1><p>1.安装nsenter<br>cd /tmp<br>curl <a href="https://www.kernel.org/pub/linux/utils/util-linux/v2.24/util-linux-2.24.tar.gz" target="_blank" rel="external">https://www.kernel.org/pub/linux/utils/util-linux/v2.24/util-linux-2.24.tar.gz</a> | tar -zxf-<br>cd util-linux-2.24<br>./configure –without-ncurses<br>make nsenter<br>cp nsenter /usr/local/bin<br>2.写如下脚本保存为docker-enter<br>并保存至bin/下面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh</div><div class="line"></div><div class="line">if [ -e $(dirname &quot;$0&quot;)/nsenter ]; then</div><div class="line">  # with boot2docker, nsenter is not in the PATH but it is in the same folder</div><div class="line">  NSENTER=$(dirname &quot;$0&quot;)/nsenter</div><div class="line">else</div><div class="line">  NSENTER=nsenter</div><div class="line">fi</div><div class="line"></div><div class="line">if [ -z &quot;$1&quot; ]; then</div><div class="line">  echo &quot;Usage: `basename &quot;$0&quot;` CONTAINER [COMMAND [ARG]...]&quot;</div><div class="line">  echo &quot;&quot;</div><div class="line">  echo &quot;Enters the Docker CONTAINER and executes the specified COMMAND.&quot;</div><div class="line">  echo &quot;If COMMAND is not specified, runs an interactive shell in CONTAINER.&quot;</div><div class="line">else</div><div class="line">  PID=$(docker inspect --format &quot;&#123;&#123;.State.Pid&#125;&#125;&quot; &quot;$1&quot;)</div><div class="line">  if [ -z &quot;$PID&quot; ]; then</div><div class="line">    exit 1</div><div class="line">  fi</div><div class="line">  shift</div><div class="line"></div><div class="line">  OPTS=&quot;--target $PID --mount --uts --ipc --net --pid --&quot;</div><div class="line"></div><div class="line">  if [ -z &quot;$1&quot; ]; then</div><div class="line">    # No command given.</div><div class="line">    # Use su to clear all host environment variables except for TERM,</div><div class="line">    # initialize the environment variables HOME, SHELL, USER, LOGNAME, PATH,</div><div class="line">    # and start a login shell.</div><div class="line">    &quot;$NSENTER&quot; $OPTS su - root</div><div class="line">  else</div><div class="line">    # Use env to clear all host environment variables.</div><div class="line">    &quot;$NSENTER&quot; $OPTS env --ignore-environment -- &quot;$@&quot;</div><div class="line">  fi</div><div class="line">fi</div></pre></td></tr></table></figure>
<h1 id="ubuntu容器镜像语言设置问题"><a href="#ubuntu容器镜像语言设置问题" class="headerlink" title="ubuntu容器镜像语言设置问题"></a>ubuntu容器镜像语言设置问题</h1><ol>
<li><p>查看安装语言<br>locale -a</p>
</li>
<li><p>安装相关语言<br>locale-gen en_US.UTF-8<br>locale-gen zh_CN.UTF-8</p>
</li>
</ol>
<p>三步曲<br>a. vim /var/lib/locales/supported.d/<br>加入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">zh_CN.UTF-8 UTF-8</div><div class="line">zh_CN GB2312</div><div class="line">zh_CN.GBK GBK</div><div class="line">en_US.UTF-8 UTF-8</div><div class="line">fr_FR ISO-8859-1</div><div class="line">zh_CN.GB18030 GB18030</div></pre></td></tr></table></figure></p>
<p>b. 生成相关locales<br>locale-gen –purge</p>
<p>c. vim /etc/default/locale</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LANG=&quot;zh_CN.UTF-8&quot;</div><div class="line">LANGUAGE=&quot;zh_CN:zh&quot;</div><div class="line">LC_ALL=&quot;zh_CN.UTF-8&quot;</div></pre></td></tr></table></figure>
<p>reboot并检测locale命令</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/01/常用linux命令-总结/" itemprop="url">
                  我常用的linux命令总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-01T01:01:59+00:00" content="2016-08-01">
              2016-08-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/01/常用linux命令-总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/01/常用linux命令-总结/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>现在大部分程序员开发基本在开发机linux环境，熟悉linux能够大大的提升开发效率，这篇博客就用来持续更新自己常常使用的linux命令吧，持续更新。。。</p>
<h2 id="进程与网络"><a href="#进程与网络" class="headerlink" title="进程与网络"></a>进程与网络</h2><h3 id="非常重要的命令netstat"><a href="#非常重要的命令netstat" class="headerlink" title="非常重要的命令netstat"></a>非常重要的命令netstat</h3><p>常见参数<br>-a (all)显示所有选项，默认不显示LISTEN相关<br>-t (tcp)仅显示tcp相关选项<br>-u (udp)仅显示udp相关选项<br>-n 拒绝显示别名，能显示数字的全部转化成数字。<br>-l 仅列出有在 Listen (监听) 的服務状态</p>
<p>-p 显示建立相关链接的程序名<br>-r 显示路由信息，路由表<br>-e 显示扩展信息，例如uid等<br>-s 按各个协议进行统计<br>-c 每隔一个固定时间，执行该netstat命令。</p>
<p>提示：LISTEN和LISTENING的状态只有用-a或者-l才能看到</p>
<h3 id="netstat查看redis客户端的tcp连接状态，ip以及端口号等"><a href="#netstat查看redis客户端的tcp连接状态，ip以及端口号等" class="headerlink" title="netstat查看redis客户端的tcp连接状态，ip以及端口号等"></a>netstat查看redis客户端的tcp连接状态，ip以及端口号等</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -nap | grep redis</div></pre></td></tr></table></figure>
<h3 id="虚拟内存状态"><a href="#虚拟内存状态" class="headerlink" title="虚拟内存状态"></a>虚拟内存状态</h3><p>vmstat<br>-a：显示活动内页；<br>-f：显示启动后创建的进程总数；<br>-m：显示slab信息；<br>-n：头信息仅显示一次；<br>-s：以表格方式显示事件计数器和内存状态；<br>-d：报告磁盘状态；<br>-p：显示指定的硬盘分区状态；<br>-S：输出信息的单位。<br>字段说明： </p>
<h3 id="Procs（进程）"><a href="#Procs（进程）" class="headerlink" title="Procs（进程）"></a>Procs（进程）</h3><p>r: 运行队列中进程数量，这个值也可以判断是否需要增加CPU。（长期大于1）<br>b: 等待IO的进程数量。 Memory（内存）<br>swpd: 使用虚拟内存大小，如果swpd的值不为0，但是SI，SO的值长期为0，这种情况不会影响系统性能。<br>free: 空闲物理内存大小。<br>buff: 用作缓冲的内存大小。<br>cache: 用作缓存的内存大小，如果cache的值大的时候，说明cache处的文件数多，如果频繁访问到的文件都能被cache处，那么磁盘的读IO bi会非常小。 </p>
<h3 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h3><p>si: 每秒从交换区写到内存的大小，由磁盘调入内存。 </p>
<p>so: 每秒写入交换区的内存大小，由内存调入磁盘。 注意：内存够用的时候，这2个值都是0，如果这2个值长期大于0时，系统性能会受到影响，磁盘IO和CPU资源都会被消耗。有些朋友看到空闲内存（free）很少的或接近于0时，就认为内存不够用了，不能光看这一点，还要结合si和so，如果free很少，但是si和so也很少（大多时候是0），那么不用担心，系统性能这时不会受到影响的。 </p>
<h3 id="IO（现在的Linux版本块的大小为1kb）"><a href="#IO（现在的Linux版本块的大小为1kb）" class="headerlink" title="IO（现在的Linux版本块的大小为1kb）"></a>IO（现在的Linux版本块的大小为1kb）</h3><p>bi: 每秒读取的块数<br>bo: 每秒写入的块数 注意：随机磁盘读写的时候，这2个值越大（如超出1024k)，能看到CPU在IO等待的值也会越大。 </p>
<h3 id="system（系统）"><a href="#system（系统）" class="headerlink" title="system（系统）"></a>system（系统）</h3><p>in: 每秒中断数，包括时钟中断。 </p>
<p>cs: 每秒上下文切换数。 注意：上面2个值越大，会看到由内核消耗的CPU时间会越大。 CPU（以百分比表示） </p>
<p>us: 用户进程执行时间百分比(user time) us的值比较高时，说明用户进程消耗的CPU时间多，但是如果长期超50%的使用，那么我们就该考虑优化程序算法或者进行加速。</p>
<p>sy: 内核系统进程执行时间百分比(system time) sy的值高时，说明系统内核消耗的CPU资源多，这并不是良性表现，我们应该检查原因。 </p>
<p>wa: IO等待时间百分比 wa的值高时，说明IO等待比较严重，这可能由于磁盘大量作随机访问造成，也有可能磁盘出现瓶颈（块操作）。 </p>
<p>id: 空闲时间百分比</p>
<h3 id="磁盘负载"><a href="#磁盘负载" class="headerlink" title="磁盘负载"></a>磁盘负载</h3><p>apt-get install sysstat<br>iostat<br>-c：仅显示CPU使用情况； -d：仅显示设备利用率； -k：显示状态以千字节每秒为单位，而不使用块每秒； -m：显示状态以兆字节每秒为单位； -p：仅显示块设备和所有被使用的其他分区的状态； -t：显示每个报告产生时的时间； -V：显示版号并退出； -x：显示扩展状态。</p>
<p>Device: 以sdX形式显示的设备名称<br>tps: 每秒进程下发的IO读、写请求数量<br>Blk_read/s: 每秒读扇区数量(一扇区为512bytes)<br>Blk_wrtn/s: 每秒写扇区数量<br>Blk_read: 取样时间间隔内读扇区总数量<br>Blk_wrtn: 取样时间间隔内写扇区总数量</p>
<p>$iostat -x -k -d 1<br>rrqm/s: 每秒对该设备的读请求被合并次数，文件系统会对读取同块(block)的请求进行合并<br>wrqm/s: 每秒对该设备的写请求被合并次数<br>r/s: 每秒完成的读次数<br>w/s: 每秒完成的写次数<br>rkB/s: 每秒读数据量(kB为单位)<br>wkB/s: 每秒写数据量(kB为单位)<br>avgrq-sz:平均每次IO操作的数据量(扇区数为单位)<br>avgqu-sz: 平均等待处理的IO请求队列长度<br>await: 平均每次IO请求等待时间(包括等待时间和处理时间，毫秒为单位)<br>svctm: 平均每次IO请求的处理时间(毫秒为单位)<br>%util: 采用周期内用于IO操作的时间比率，即IO队列非空的时间比率</p>
<h3 id="当前目录大小"><a href="#当前目录大小" class="headerlink" title="当前目录大小"></a>当前目录大小</h3><p>du -h –max-depth=1 ./</p>
<h3 id="ps命令通过进程名查看进程PID以及父进程ID-时间等"><a href="#ps命令通过进程名查看进程PID以及父进程ID-时间等" class="headerlink" title="ps命令通过进程名查看进程PID以及父进程ID,时间等"></a>ps命令通过进程名查看进程PID以及父进程ID,时间等</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -ef | grep　php-fpm</div></pre></td></tr></table></figure>
<p>-A：显示所有程序。<br>-f：显示UID,PPIP,C与STIME栏位。</p>
<h3 id="lsof定位具体端口号是那个进程在占有-显示器进程名，进程id-协议以及状态"><a href="#lsof定位具体端口号是那个进程在占有-显示器进程名，进程id-协议以及状态" class="headerlink" title="lsof定位具体端口号是那个进程在占有,显示器进程名，进程id,协议以及状态"></a>lsof定位具体端口号是那个进程在占有,显示器进程名，进程id,协议以及状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lsof -i:8080</div></pre></td></tr></table></figure>
<h3 id="kill-强制终止进程号为8080的进程"><a href="#kill-强制终止进程号为8080的进程" class="headerlink" title="kill 强制终止进程号为8080的进程"></a>kill 强制终止进程号为8080的进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">kill</span> -9 8080</div></pre></td></tr></table></figure>
<h3 id="已知进程名称，杀死所有相关的程序"><a href="#已知进程名称，杀死所有相关的程序" class="headerlink" title="已知进程名称，杀死所有相关的程序"></a>已知进程名称，杀死所有相关的程序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ps -ef | grep press.php | grep -v grep | awk <span class="string">'&#123;print $2&#125;'</span> | xargs <span class="built_in">kill</span> -9</div><div class="line">```</div></pre></td></tr></table></figure>
<h3 id="pwdx查看进程id对应进程程序所在目录"><a href="#pwdx查看进程id对应进程程序所在目录" class="headerlink" title="pwdx查看进程id对应进程程序所在目录"></a>pwdx查看进程id对应进程程序所在目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pwdx 14190</div></pre></td></tr></table></figure>
<h3 id="proc-14190-查看进程id对应运行中的进程的信息"><a href="#proc-14190-查看进程id对应运行中的进程的信息" class="headerlink" title="/proc/14190 查看进程id对应运行中的进程的信息"></a>/proc/14190 查看进程id对应运行中的进程的信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls <span class="_">-l</span> /proc/14190</div></pre></td></tr></table></figure>
<p>有关运行中的进程的信息</p>
<p>/proc 文件系统可以用于获取运行中的进程的信息。在/proc 中有一些编号的子目录。每个编号的目录对应一个进程id (PID)。这样，每一个运行中的进程/proc 中都有一个用它的PID 命名的目录。这些子目录中包含可以提供有关进程的状态和环境的重要细节信息的文件。让我们试着查找一个运行中的进程。</p>
<h3 id="top-查看系统负载，cpu，内存使用，下面只查单进程状态"><a href="#top-查看系统负载，cpu，内存使用，下面只查单进程状态" class="headerlink" title="top 查看系统负载，cpu，内存使用，下面只查单进程状态"></a>top 查看系统负载，cpu，内存使用，下面只查单进程状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">top -Hp 进程号</div></pre></td></tr></table></figure>
<h3 id="pstree查看进程号对应进程名字"><a href="#pstree查看进程号对应进程名字" class="headerlink" title="pstree查看进程号对应进程名字"></a>pstree查看进程号对应进程名字</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pstree -p 进程号</div></pre></td></tr></table></figure>
<h3 id="查看路由表"><a href="#查看路由表" class="headerlink" title="查看路由表"></a>查看路由表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -r</div></pre></td></tr></table></figure>
<h2 id="文件目录操作"><a href="#文件目录操作" class="headerlink" title="文件目录操作"></a>文件目录操作</h2><h3 id="常见的rm-touch-mkdir-mv-cp-cd-mv"><a href="#常见的rm-touch-mkdir-mv-cp-cd-mv" class="headerlink" title="常见的rm,touch,mkdir,mv,cp,cd,mv,"></a>常见的rm,touch,mkdir,mv,cp,cd,mv,</h3><h3 id="查找a开头的文件并删除"><a href="#查找a开头的文件并删除" class="headerlink" title="查找a开头的文件并删除"></a>查找a开头的文件并删除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find / -name a* |xargs rm -rf</div></pre></td></tr></table></figure>
<h3 id="查找所有fis开头的配置文件并将其中配置文件的localhost替换为127-0-0-1（常用于配环境）"><a href="#查找所有fis开头的配置文件并将其中配置文件的localhost替换为127-0-0-1（常用于配环境）" class="headerlink" title="查找所有fis开头的配置文件并将其中配置文件的localhost替换为127.0.0.1（常用于配环境）"></a>查找所有fis开头的配置文件并将其中配置文件的localhost替换为127.0.0.1（常用于配环境）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find -name fis* ./  | xargs sed -i <span class="string">"%s/localhost/127.0.0.1/g"</span></div></pre></td></tr></table></figure>
<h3 id="将a-b-c移动到d-将非某文件名的文件移动到某目录下"><a href="#将a-b-c移动到d-将非某文件名的文件移动到某目录下" class="headerlink" title="将a,b,c移动到d,将非某文件名的文件移动到某目录下"></a>将a,b,c移动到d,将非某文件名的文件移动到某目录下</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mv a b c d</div><div class="line">mv !(a) dir</div></pre></td></tr></table></figure>
<h3 id="sed替换文件名中内容"><a href="#sed替换文件名中内容" class="headerlink" title="sed替换文件名中内容"></a>sed替换文件名中内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sed <span class="string">'2s/localhost/127.0.0.1/g'</span> 12.txt</div><div class="line">2表示第2行</div><div class="line">s/表示替换</div><div class="line">1,n表示1,n行</div><div class="line">g表示全局替换</div></pre></td></tr></table></figure>
<h3 id="查找a开头的文件并删除-1"><a href="#查找a开头的文件并删除-1" class="headerlink" title="查找a开头的文件并删除"></a>查找a开头的文件并删除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find / -name a* |xargs rm -rf</div></pre></td></tr></table></figure>
<h3 id="head-查看文件的前几行"><a href="#head-查看文件的前几行" class="headerlink" title="head 查看文件的前几行"></a>head 查看文件的前几行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">head 10 1.log</div></pre></td></tr></table></figure>
<h3 id="tail-查看文件的末几行"><a href="#tail-查看文件的末几行" class="headerlink" title="tail 查看文件的末几行"></a>tail 查看文件的末几行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tail 10 1.log</div></pre></td></tr></table></figure>
<h3 id="tailf-查看最后匹配的内容，并且一直阻塞等待日志文件的更新，常用于日志的调试查看"><a href="#tailf-查看最后匹配的内容，并且一直阻塞等待日志文件的更新，常用于日志的调试查看" class="headerlink" title="tailf 查看最后匹配的内容，并且一直阻塞等待日志文件的更新，常用于日志的调试查看"></a>tailf 查看最后匹配的内容，并且一直阻塞等待日志文件的更新，常用于日志的调试查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tailf 123.log | grep gointhis</div></pre></td></tr></table></figure>
<h3 id="grep非常快，sunday算法实现做了底层优化，比KMP易理解"><a href="#grep非常快，sunday算法实现做了底层优化，比KMP易理解" class="headerlink" title="grep非常快，sunday算法实现做了底层优化，比KMP易理解"></a>grep非常快，sunday算法实现做了底层优化，比KMP易理解</h3><h3 id="grep在多个文件中查找："><a href="#grep在多个文件中查找：" class="headerlink" title="grep在多个文件中查找：("></a>grep在多个文件中查找：(</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grep <span class="string">"match_pattern"</span> file_1 file_2 file_3 ...</div><div class="line">grep <span class="string">"text"</span> -n file_name</div><div class="line">```</div></pre></td></tr></table></figure>
<h2 id="系统与负载"><a href="#系统与负载" class="headerlink" title="系统与负载"></a>系统与负载</h2><h3 id="查询系统具有多少个逻辑核："><a href="#查询系统具有多少个逻辑核：" class="headerlink" title="查询系统具有多少个逻辑核："></a>查询系统具有多少个逻辑核：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /proc/cpuinfo | grep <span class="string">"processor"</span> | wc <span class="_">-l</span></div></pre></td></tr></table></figure>
<h3 id="查询系统CPU的物理核数："><a href="#查询系统CPU的物理核数：" class="headerlink" title="查询系统CPU的物理核数："></a>查询系统CPU的物理核数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /proc/cpuinfo | grep <span class="string">"cpu cores"</span> | uniq</div></pre></td></tr></table></figure>
<h3 id="查询系统CPU是否启用超线程："><a href="#查询系统CPU是否启用超线程：" class="headerlink" title="查询系统CPU是否启用超线程："></a>查询系统CPU是否启用超线程：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /proc/cpuinfo | grep <span class="_">-e</span> <span class="string">"cpu cores"</span>  <span class="_">-e</span> <span class="string">"siblings"</span> | sort | uniq</div></pre></td></tr></table></figure>
<h3 id="查询系统CPU的个数："><a href="#查询系统CPU的个数：" class="headerlink" title="查询系统CPU的个数："></a>查询系统CPU的个数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /proc/cpuinfo | grep <span class="string">"physical id"</span> | sort | uniq | wc <span class="_">-l</span></div></pre></td></tr></table></figure>
<h2 id="压缩-解压缩"><a href="#压缩-解压缩" class="headerlink" title="压缩-解压缩"></a>压缩-解压缩</h2><p><em>.tar 用 tar –xvf 解压
</em>.tar.gz和*.tgz 用 tar –xzf 解压</p>
<h3 id="zip压缩与解压缩"><a href="#zip压缩与解压缩" class="headerlink" title="zip压缩与解压缩"></a>zip压缩与解压缩</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">zip -r filename.zip dir/file</div><div class="line">unzip filename</div></pre></td></tr></table></figure>
<p>linux正则匹配电话号码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat file.txt | grep -Eo &quot;^(\([0-9]&#123;3&#125;\) )&#123;1&#125;[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$|^([0-9]&#123;3&#125;-)&#123;2&#125;[0-9]&#123;4&#125;$&quot;</div></pre></td></tr></table></figure>
<p>linux打印第N行</p>
<p>方法一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk &apos;NR==10&apos; file.txt  //awk的默认动作就是打印$0，所以NR==10后面可以不用加&#123;print $0&#125;</div></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n &apos;10p&apos; file.txt  //如果不够10行，则什么也不打印</div></pre></td></tr></table></figure>
<p>方法三：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">line=$(cat file.txt | wc -l)     //千万注意，等号前后一定不要有空格</div><div class="line">if [ &quot;$line&quot; -ge 10 ] ; then   //$line的双引号也可以不用加</div><div class="line">  cat file.txt | head -n 10 | tail -n 1</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>linux 统计单词数据并按频次降序<br>一行命令<br>方法一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat words.txt | tr -s &apos; &apos; &apos;\n&apos; | sort | uniq -c | sort -nr | awk &apos;&#123;print $2 &quot; &quot; $1&#125;&apos;</div></pre></td></tr></table></figure>
<p>解释：<br>tr -s ‘ ‘ ‘\n’  用换行替换空格，这样每一行就是一个单词了<br>sort -nr n是以数字排序 r是逆序（降序）</p>
<p>方法二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">awk &apos;</div><div class="line">&#123;for(i=1;i&lt;=NF;i++)</div><div class="line">&#123;s[$i]++;&#125;</div><div class="line">&#125;</div><div class="line">END&#123;</div><div class="line">for(i in s)</div><div class="line">&#123;print i &quot; &quot; s[i]&#125;</div><div class="line">&#125;&apos; words.txt | sort -nr -k 2</div></pre></td></tr></table></figure>
<p>sort的k参数是以第几列来排序的意思</p>
<p>对于文本行按列聚合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">awk &apos;&#123;</div><div class="line">	for(i=1;i&lt;=NF;i++)&#123; </div><div class="line">		if(NR==1)&#123; s[i]=$i;</div><div class="line">		&#125; </div><div class="line">		else&#123; s[i]=s[i]&quot; &quot;$i;&#125;</div><div class="line">		&#125;</div><div class="line">	&#125; </div><div class="line">END&#123;</div><div class="line">	for(i=1;s[i]!=&quot;&quot;;i++) </div><div class="line">&#125;&apos; file.txt</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/16/redis持久化之AOF&RDB/" itemprop="url">
                  redis持久化之RDB与AOF
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-16T13:38:59+00:00" content="2016-07-16">
              2016-07-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Redis学习/" itemprop="url" rel="index">
                    <span itemprop="name">Redis学习</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/16/redis持久化之AOF&RDB/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/16/redis持久化之AOF&RDB/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道redis是内存数据库，如果不将数据库转态(当前服务器非空数据库以及键值对)保存在内存中,就得保存在磁盘里，否则一旦服务器退出，服务器中的数据库转态也会消失<br>为了解决这个问题，redis采用了两种持久化方式，一种为RDB，一种为AOF</p>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>rdb方式就是手动或者配置定期化将数据库以及键值对保存到一个RDB文件中，称之为RDB持久化，这里需要了解的是:</p>
<div align="center"><br><img src="/img/rdb.jpg"><br></div>

<h3 id="RDB如何是如何创建的，执行SAVE或者BGSAVE的流程"><a href="#RDB如何是如何创建的，执行SAVE或者BGSAVE的流程" class="headerlink" title="RDB如何是如何创建的，执行SAVE或者BGSAVE的流程"></a>RDB如何是如何创建的，执行SAVE或者BGSAVE的流程</h3><p>BGSAVE主要的实现是利用fork()创建一个子进程，保存工作由子进程执行，所以子进程在创建子进程的过程中，Redis服务器仍然可以响应客户端请求而不会阻塞，但是在BGSAVE的过程中，拒绝BGSAVE,SAVE执行，BGREWRITEAOF延迟执行，主要为了避免竞争。<br>子进程：fork()-&gt;rdbsave(…)-&gt;_exit()||exit()<br>父进程：记录fork与子进程相关信息，输出日志，然后马上返回状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveBackground</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line">    <span class="keyword">pid_t</span> childpid;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) <span class="keyword">return</span> C_ERR;</div><div class="line"></div><div class="line">    server.dirty_before_bgsave = server.dirty;</div><div class="line">    server.lastbgsave_try = time(<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    start = ustime();</div><div class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123; </div><div class="line">        <span class="keyword">int</span> retval;</div><div class="line"></div><div class="line">        <span class="comment">/* Child */</span></div><div class="line">        closeListeningSockets(<span class="number">0</span>);</div><div class="line">        redisSetProcTitle(<span class="string">"redis-rdb-bgsave"</span>);</div><div class="line">        retval = rdbSave(filename);</div><div class="line">        <span class="keyword">if</span> (retval == C_OK) &#123;</div><div class="line">            <span class="keyword">size_t</span> private_dirty = zmalloc_get_private_dirty();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (private_dirty) &#123;</div><div class="line">                serverLog(LL_NOTICE,</div><div class="line">                    <span class="string">"RDB: %zu MB of memory used by copy-on-write"</span>,</div><div class="line">                    private_dirty/(<span class="number">1024</span>*<span class="number">1024</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        exitFromChild((retval == C_OK) ? <span class="number">0</span> : <span class="number">1</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/* Parent */</span></div><div class="line">        server.stat_fork_time = ustime()-start;</div><div class="line">        server.stat_fork_rate = (<span class="keyword">double</span>) zmalloc_used_memory() * <span class="number">1000000</span> / server.stat_fork_time / (<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>); <span class="comment">/* GB per second. */</span></div><div class="line">        latencyAddSampleIfNeeded(<span class="string">"fork"</span>,server.stat_fork_time/<span class="number">1000</span>);</div><div class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</div><div class="line">            server.lastbgsave_status = C_ERR;</div><div class="line">            serverLog(LL_WARNING,<span class="string">"Can't save in background: fork: %s"</span>,</div><div class="line">                strerror(errno));</div><div class="line">            <span class="keyword">return</span> C_ERR;</div><div class="line">        &#125;</div><div class="line">        serverLog(LL_NOTICE,<span class="string">"Background saving started by pid %d"</span>,childpid);</div><div class="line">        server.rdb_save_time_start = time(<span class="literal">NULL</span>);</div><div class="line">        server.rdb_child_pid = childpid;</div><div class="line">        server.rdb_child_type = RDB_CHILD_TYPE_DISK;</div><div class="line">        updateDictResizePolicy();</div><div class="line">        <span class="keyword">return</span> C_OK;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> C_OK; <span class="comment">/* unreached */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* After an RDB dump or AOF rewrite we exit from children using _exit() instead of</span></div><div class="line"> * exit(), because the latter may interact with the same file objects used by</div><div class="line"> * the parent process. However if we are testing the coverage normal exit() is</div><div class="line"> * used in order to obtain the right coverage information. */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">exitFromChild</span><span class="params">(<span class="keyword">int</span> retcode)</span> </span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COVERAGE_TEST</span></div><div class="line">    <span class="built_in">exit</span>(retcode);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="number">_</span><span class="built_in">exit</span>(retcode);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="如何定期保存"><a href="#如何定期保存" class="headerlink" title="如何定期保存"></a>如何定期保存</h3><p>服务器除了记录saveparam这样的结构体数组来保存用户自定义的多个保存条件<br>(在多少秒之内进行了多少次修改),还另外记录了dirty，即每一次执行一个数据库修改命令，程序对dirty计数加一，lastsave是上一次执行保存的时间，redis的服务器周期性函数servercron默认每隔100ms检查save选项所设置的保存条件是否满足</p>
<p>``` C<br>struct redisServer{<br>    /<em> RDB persistence </em>/<br>    long long dirty;                /<em> Changes to DB from the last save </em>/<br>    pid_t rdb_child_pid;            /<em> PID of RDB saving child </em>/<br>    struct saveparam <em>saveparams;   /</em> Save points array for RDB <em>/<br>    time_t lastsave;                /</em> Unix time of last successful save */</p>
<p>}</p>
<h3 id="RDB文件结构设计"><a href="#RDB文件结构设计" class="headerlink" title="RDB文件结构设计"></a>RDB文件结构设计</h3><p>RDB文件是一个经过压缩的二进制文件，由多个部分组成</p>
<div align="center"><br><img src="/img/rdbfile.jpg"><br></div>

<div align="center"><br><img src="/img/rdbfile1.jpg"><br></div>

<div align="center"><br><img src="/img/rdbfile2.jpg"><br></div><br>## AOF<br>RDB是通过保存数据库的键值对来记录数据库转态，而AOF(APPEND ONLY FILE)持久化则是通过保存redis服务器所执行的写命令来记录数据库转态的<br><div align="center"><br><img src="/img/aof.jpg"><br></div>

<h3 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a>实现要点</h3><p>未完待续</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote>
<p>《redis设计与实现》<br> redis github源码</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/06/redis中跳表分析(vs红黑树)/" itemprop="url">
                  redis中跳表实现(vs红黑树)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-06T17:38:59+00:00" content="2016-07-06">
              2016-07-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Redis学习/" itemprop="url" rel="index">
                    <span itemprop="name">Redis学习</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/06/redis中跳表分析(vs红黑树)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/06/redis中跳表分析(vs红黑树)/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 用过sorted set的话，都知道sorted set是redis非常首欢迎的数据结构，Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。<br> 而sorted set的底层实现便是skiplist,支持平均O(n)，最坏O(n)的查找时间复杂度</p>
<h2 id="跳表与红黑树"><a href="#跳表与红黑树" class="headerlink" title="跳表与红黑树?"></a>跳表与红黑树?</h2><p>虽然我们知道redis用skiplist用实现排序集,但了解过C++ STL的源码实现相关资料就会产生疑问,类似于redis的sorted set，STL的set,multiset,map,multimap底层均采用的RB-tree这里,这里skiplist与RB-Tree究竟有啥不一样,作者为何采用skiplist,它们有什么优缺点?在并行编程与利用并行硬件方面其特性表现如何？</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树是一种平衡二叉搜索树，自动排序效果不错，可在平均时间复杂度O(logn)内完成查找，插入，删除等操作,其基本性质如下：<br>性质1. 节点是红色或黑色<br>性质2. 根是黑色<br>性质3. 所有叶子都是黑色（叶子是NIL节点）<br>性质4. 如果一个节点是红的，则它的两个儿子都是黑的<br>性质5. 从任一节点到其叶子的所有简单路径都包含相同数目的黑色节点。<br>关于红黑树插入删除的不同情况下树的调整可阅读STL源码解析。其实现过程还是非常繁杂的，而skiplist相对来说是比较简单的。</p>
<h2 id="skiplist结构定义"><a href="#skiplist结构定义" class="headerlink" title="skiplist结构定义"></a>skiplist结构定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplistNode &#123;</div><div class="line">    sds ele;  <span class="comment">//与C风格兼容的字符串,空间预分配,重新配策略防止缓存区溢出</span></div><div class="line">    <span class="keyword">double</span> score; <span class="comment">//节点分值</span></div><div class="line">    <span class="keyword">struct</span> zskiplistNode *backward; <span class="comment">//后退指针</span></div><div class="line">    <span class="keyword">struct</span> zskiplistLevel &#123;</div><div class="line">        <span class="keyword">struct</span> zskiplistNode *forward;<span class="comment">//前进指针</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span; <span class="comment">//跨度,记录两个节点之间的距离</span></div><div class="line">    &#125; level[];</div><div class="line">&#125; zskiplistNode;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplist &#123;</div><div class="line">    <span class="keyword">struct</span> zskiplistNode *header, *tail;<span class="comment">//指向跳跃表的头节点和尾节点</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;<span class="comment">//表中节点数量</span></div><div class="line">    <span class="keyword">int</span> level;<span class="comment">//节点中的最大层数</span></div><div class="line">&#125; zskiplist;</div></pre></td></tr></table></figure>
<h2 id="跳表的实现原理"><a href="#跳表的实现原理" class="headerlink" title="跳表的实现原理"></a>跳表的实现原理</h2><p>我们知道在一个单链有序表搜索的时候，查找成功的平均时间复杂度O(n+1/2)<br>从该有序表中搜索元素 &lt; 23, 43, 59 &gt; ，需要比较的次数分别为 &lt; 2, 4, 6 &gt;，总共比较的次数为 2 + 4 + 6 = 12 次</p>
<div align="center"><br><img src="/img/skiplist1.jpg"><br></div><br>如果我们把一些节点提取出来作为索引,发现搜索次数减少<br><div align="center"><br><img src="/img/skiplist2.jpg"><br></div><br>我们还可以再从一级索引提取一些元素出来，作为二级索引，变成如下结构<br><div align="center"><br><img src="/img/skiplist3.jpg"><br></div><br><strong>从中可以看出跳表的核心思想，其实是一种空间换时间的做法，通过每增加每个节点向前的指针，同时存储多层指针。跳跃列表是按层建造的。底层是一个普通的有序链表。每个更高层都充当下面列表的「快速跑道」，这里在层 i 中的元素按某个固定的概率 p (通常<br>为0.5或0.25)出现在层 i+1 中。平均起来，每个元素都在 1/(1-p) 个列表中出现, 而最高层的元素（通常是在跳跃列表前端的一个特殊的头元素）<br>在 O(log1/p n) 个列表中出现。我们知道红黑树充分利用了节点的索引性质来加速查找效率，跳表其实也含有这么一种思想在里面，充分利用节点索引</strong><br><br><div align="center"><br><img src="/img/skiplist4.jpg"><br></div>

<h2 id="skiplist基本实现"><a href="#skiplist基本实现" class="headerlink" title="skiplist基本实现"></a>skiplist基本实现</h2><h3 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">/* 创建一个skiplist */ </div><div class="line">zskiplist *zslCreate(void);</div><div class="line"></div><div class="line">/* 创建一个skiplist节点 */</div><div class="line">zskiplistNode *zslCreateNode(int level, double score, robj *obj)；</div><div class="line"></div><div class="line">/* 释放一个节点的内存 */</div><div class="line">void zslFreeNode(zskiplistNode *node);</div><div class="line"></div><div class="line">/* 释放整个skiplist */</div><div class="line">void zslFree(zskiplist *zsl);</div><div class="line"></div><div class="line">/* 插入一个节点 */</div><div class="line">zskiplistNode *zslInsert(zskiplist *zsl, double score, robj *obj);</div><div class="line"></div><div class="line">/* 删除一个节点，根据score删除 */</div><div class="line">int zslDelete(zskiplist *zsl, double score, robj *obj);</div><div class="line"></div><div class="line">/*这个函数是查询某个节点对应的排名,其实就是在跳表中位置*/</div><div class="line">unsigned long zslGetRank(zskiplist *zsl, double score, robj *o);  </div><div class="line"></div><div class="line">```</div></pre></td></tr></table></figure>
<h3 id="重要实现函数解析"><a href="#重要实现函数解析" class="headerlink" title="重要实现函数解析"></a>重要实现函数解析</h3><p>以下是插入操作的实现,先看个跳表整体详细结构图</p>
<p><div align="center"><br><img src="/img/skiplist.jpg"><br></div><br>看上图，我们知道跳表的插入实现和单链表的插入式类似的，只不过现在每个节点含有多层,非常需要找到每层对应的插入节点前后指针以及跨度<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Insert a new node in the skiplist. Assumes the element does not already</span></div><div class="line"> * exist (up to the caller to enforce that). The skiplist takes ownership</div><div class="line"> * of the passed SDS string 'ele'. */</div><div class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</div><div class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];</div><div class="line">    <span class="keyword">int</span> i, level;</div><div class="line"></div><div class="line">    serverAssert(!isnan(score));</div><div class="line">    x = zsl-&gt;header;</div><div class="line">    <span class="comment">/*记录新节点应插入位置，即每一层的前后指向节点,便于关联节点后续更新指向*/</span></div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="comment">/* store rank that is crossed to reach the insert position */</span></div><div class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</div><div class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</div><div class="line">        &#123;</div><div class="line">            rank[i] += x-&gt;level[i].span;</div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        &#125;</div><div class="line">        update[i] = x;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* we assume the element is not already inside, since we allow duplicated</span></div><div class="line">     * scores, reinserting the same element should never happen since the</div><div class="line">     * caller of zslInsert() should test in the hash table if the element is</div><div class="line">     * already inside or not. */</div><div class="line">     <span class="comment">/*生成新节点的随机层数,详细函数见后续内容*/</span></div><div class="line">    level = zslRandomLevel();</div><div class="line">    <span class="comment">//如果随机生成层大于当前跳表层数，更新</span></div><div class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</div><div class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</div><div class="line">            rank[i] = <span class="number">0</span>;</div><div class="line">            update[i] = zsl-&gt;header;</div><div class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</div><div class="line">        &#125;</div><div class="line">        zsl-&gt;level = level;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//创建新节点</span></div><div class="line">    x = zslCreateNode(level,score,ele);</div><div class="line">    <span class="comment">//更新新节点的每一层,使之插入跳表</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123; </div><div class="line">        <span class="comment">//类似于单链表的节点插入步奏</span></div><div class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</div><div class="line">        update[i]-&gt;level[i].forward = x;</div><div class="line">        <span class="comment">//更新跨度</span></div><div class="line">        <span class="comment">/* update span covered by update[i] as x is inserted here */</span></div><div class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</div><div class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* increment span for untouched levels */</span></div><div class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</div><div class="line">        update[i]-&gt;level[i].span++;<span class="comment">//前一个节点其他未连层跨度加1</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//更新后向指针</span></div><div class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</div><div class="line">    <span class="comment">//如果是最后一个节点</span></div><div class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</div><div class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        zsl-&gt;tail = x;</div><div class="line">    <span class="comment">//跳表节点数加1</span></div><div class="line">    zsl-&gt;length++;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Returns a random level for the new skiplist node we are going to create.</span></div><div class="line"> * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL</div><div class="line"> * (both inclusive), with a powerlaw-alike distribution where higher</div><div class="line"> * levels are less likely to be returned. */</div><div class="line">/ <span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_P 0.25      <span class="comment">/* Skiplist P = 1/4 */</span></span></div><div class="line"><span class="comment">/*random返回0-2^32-1的一个32位整数,循环的大概意思是每次以四分之一的概率level+1,最终得到一个小于最大层数的值*/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>)) <span class="comment">//后面的值16383.75</span></div><div class="line">        level += <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="查找函数"><a href="#查找函数" class="headerlink" title="查找函数"></a>查找函数</h2><p>查询指定范围的第一个元素<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Find the first node that is contained in the specified range.</span></div><div class="line"> * Returns NULL when no element is contained in the range. */</div><div class="line"><span class="function">zskiplistNode *<span class="title">zslFirstInRange</span><span class="params">(zskiplist *zsl, zrangespec *range)</span> </span>&#123;</div><div class="line">    zskiplistNode *x;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="comment">/* If everything is out of range, return early. */</span></div><div class="line">    <span class="keyword">if</span> (!zslIsInRange(zsl,range)) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    x = zsl-&gt;header;</div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="comment">/* Go forward while *OUT* of range. */</span></div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</div><div class="line">            !zslValueGteMin(x-&gt;level[i].forward-&gt;score,range))</div><div class="line">                x = x-&gt;level[i].forward;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* This is an inner range, so the next node cannot be NULL. */</span></div><div class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</div><div class="line">    serverAssert(x != <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* Check if score &lt;= max. */</span></div><div class="line">    <span class="keyword">if</span> (!zslValueLteMax(x-&gt;score,range)) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslValueGteMin</span><span class="params">(<span class="keyword">double</span> value, zrangespec *spec)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> spec-&gt;minex ? (value &gt; spec-&gt;min) : (value &gt;= spec-&gt;min);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslValueLteMax</span><span class="params">(<span class="keyword">double</span> value, zrangespec *spec)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> spec-&gt;maxex ? (value &lt; spec-&gt;max) : (value &lt;= spec-&gt;max);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Returns if there is a part of the zset is in range. */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslIsInRange</span><span class="params">(zskiplist *zsl, zrangespec *range)</span> </span>&#123;</div><div class="line">    zskiplistNode *x;</div><div class="line"></div><div class="line">    <span class="comment">/* Test for ranges that will always be empty. */</span></div><div class="line">    <span class="keyword">if</span> (range-&gt;min &gt; range-&gt;max ||</div><div class="line">            (range-&gt;min == range-&gt;max &amp;&amp; (range-&gt;minex || range-&gt;maxex)))</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    x = zsl-&gt;tail;</div><div class="line">    <span class="keyword">if</span> (x == <span class="literal">NULL</span> || !zslValueGteMin(x-&gt;score,range))</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    x = zsl-&gt;header-&gt;level[<span class="number">0</span>].forward;</div><div class="line">    <span class="keyword">if</span> (x == <span class="literal">NULL</span> || !zslValueLteMax(x-&gt;score,range))</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">``` </div><div class="line"></div><div class="line"></div><div class="line">``` C</div><div class="line"><span class="comment">/* Struct to hold a inclusive/exclusive range spec by score comparison. */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">double</span> min, max;</div><div class="line">    <span class="keyword">int</span> minex, maxex; <span class="comment">/* are min or max exclusive? */</span></div><div class="line">&#125; zrangespec;</div><div class="line"></div><div class="line"><span class="comment">/* Struct to hold an inclusive/exclusive range spec by lexicographic comparison. */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    sds min, max;     <span class="comment">/* May be set to shared.(minstring|maxstring) */</span></div><div class="line">    <span class="keyword">int</span> minex, maxex; <span class="comment">/* are min or max exclusive? */</span></div><div class="line">&#125; zlexrangespec;</div></pre></td></tr></table></figure></p>
<h3 id="并行编程结构分析"><a href="#并行编程结构分析" class="headerlink" title="并行编程结构分析"></a>并行编程结构分析</h3><p>红黑树在更新的时候牵涉较广范围的节点，其更新不能充分利用局部特性<br>红黑树在内存与cache共享写数据与同步的代价高<br>红黑树在顺序加锁上很难想单链表那样保证正确<br>设计数据结构在并行编程性能特性分析有两点：</p>
<blockquote>
<p>第一：在并行编程方面,其性能应该考虑允许多线程在同一时间访问数据<br>第二：在并行硬件方面，最小化内存同步的代价<br>设计一个好的数据结构能够让不同的线程可以同时访问不同部分数据，并避免大的潜在的内存同步带来的开销</p>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote>
<p>《redis设计与实现》<br><a href="http://blog.csdn.net/daniel_ustc/article/details/20218489?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">http://blog.csdn.net/daniel_ustc/article/details/20218489?utm_source=tuicool&amp;utm_medium=referral</a><br><a href="http://www.drdobbs.com/parallel/choose-concurrency-friendly-data-structu/208801371?pgno=3" target="_blank" rel="external">http://www.drdobbs.com/parallel/choose-concurrency-friendly-data-structu/208801371?pgno=3</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/05/IO复用之-Select poll 和epoll/" itemprop="url">
                  linux I/O复用之-select epoll
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-05T01:01:59+00:00" content="2016-07-05">
              2016-07-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/C-与linux网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">C++与linux网络编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/05/IO复用之-Select poll 和epoll/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/05/IO复用之-Select poll 和epoll/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="I-O复用应用场景"><a href="#I-O复用应用场景" class="headerlink" title="I/O复用应用场景"></a>I/O复用应用场景</h2><blockquote>
<p>当客户同时处理多个描述符(交互式输入和网络套接字)<br>TCP服务器同时处理监听套接字和已连接套接字<br>既要处理TCP又要处理UDP<br>处理多个服务或者多个协议</p>
</blockquote>
<h2 id="五种I-O模型"><a href="#五种I-O模型" class="headerlink" title="五种I/O模型"></a>五种I/O模型</h2><p><strong>阻塞式I/O</strong></p>
<div align="center"><br><img src="/img/io1.jpg" alt="^_^||"><br></div>

<p><strong>阻塞式I/O</strong></p>
<div align="center"><br><img src="/img/io2.jpg" alt="^_^||"><br></div><br><strong>I/O复用</strong><br><div align="center"><br><img src="/img/io3.jpg" alt="^_^||"><br></div><br><strong>信号驱动式I/O</strong><br><div align="center"><br><img src="/img/io4.jpg" alt="^_^||"><br></div><br><strong>异步I/O</strong><br><div align="center"><br><img src="/img/io5.jpg" alt="^_^||"><br></div>

<h3 id="五种I-O模型总结"><a href="#五种I-O模型总结" class="headerlink" title="五种I/O模型总结"></a>五种I/O模型总结</h3><div align="center"><br><img src="/img/io-summary.jpg" alt="^_^||"><br></div>

<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>select的第一个参数为fdset集合中最大描述符值加1，select对应于内核中的sys_select调用，sys_select首先将第二三四个参数指向的fd_set拷贝到内核，然后对每个被SET的描述符进行poll，并记录在临时结果中(fdset)，如果有事件发生，select会将临时结果写到用户空间并返回，当轮询一遍后没有任何事件发生，如果指定了超时时间，则select会睡眠到超时，睡眠结束后再进行下一次轮询，并将临时结果写到用户空间，然后返回。select返回后，需要逐一检查关注的描述符是否被SET（事件是否发生）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, <span class="keyword">struct</span> timeval* timeout)</span></span>;</div></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">参数                  描述</div><div class="line">nfds             sets的文件描述符的最大值</div><div class="line">readfds          fd_set type 类型，只读的描述符集 </div><div class="line">writefds         fd_set type 类型，只写的描述符集 </div><div class="line">errorfds         fd_set type 类型，错误的描述符集 </div><div class="line">timeout          超时等待时间</div></pre></td></tr></table></figure>
<p>修改fd_set类型的参数，用到以下操作<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> fd_set</div><div class="line">&#123;</div><div class="line">    u_int fd_count;</div><div class="line">    <span class="keyword">int</span> fd_array[FD_SETSIZE];</div><div class="line">&#125;</div><div class="line"><span class="comment">//fd_array可SIZE*8个socket</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd,fd_set *fdset)</span></span>;</div><div class="line"><span class="comment">//返回值：若fd在描述符集中则返回非0值，否则返回0</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd,fd_set *fdset)</span></span>; <span class="comment">//fd指描述符</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd,fd_set *fdset)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;</div></pre></td></tr></table></figure></p>
<p>整体运行过程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> sock;</div><div class="line">FILE *fp;</div><div class="line"><span class="keyword">struct</span> fd_set fds;</div><div class="line"><span class="keyword">struct</span> timeval timeout=&#123;<span class="number">3</span>,<span class="number">0</span>&#125;; <span class="comment">//select等待3秒，3秒轮询，要非阻塞就置0</span></div><div class="line"><span class="keyword">char</span> buffer[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;; <span class="comment">//256字节的接收缓冲区</span></div><div class="line"><span class="comment">//假定已经建立UDP连接，具体过程不写，简单，当然TCP也同理，主机ip和port都已经给定，要写的文件已经打开</span></div><div class="line">sock=socket(...);</div><div class="line">bind(...);</div><div class="line">fp=fopen(...);</div><div class="line"><span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">    FD_ZERO(&amp;amp;fds); <span class="comment">//每次循环都要清空集合，否则不能检测描述符变化</span></div><div class="line">    FD_SET(sock,&amp;amp;fds); <span class="comment">//添加描述符</span></div><div class="line">    FD_SET(fp,&amp;amp;fds); <span class="comment">//同上</span></div><div class="line">    maxfdp=sock&amp;gt;fp?sock+<span class="number">1</span>:fp+<span class="number">1</span>; <span class="comment">//描述符最大值加1</span></div><div class="line">    <span class="comment">// for(int i =0 ;i &amp;lt; maxfds; i++) if(FD_ISSET()) &#123; &#125;</span></div><div class="line">    <span class="keyword">switch</span>(select(maxfdp,&amp;amp;fds,&amp;amp;fds,<span class="literal">NULL</span>,&amp;amp;timeout)) <span class="comment">//select使用</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">case</span> <span class="number">-1</span>: <span class="built_in">exit</span>(<span class="number">-1</span>);<span class="keyword">break</span>; <span class="comment">//select错误，退出程序</span></div><div class="line">        <span class="keyword">case</span> <span class="number">0</span>:<span class="keyword">break</span>; <span class="comment">//再次轮询</span></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">if</span>(FD_ISSET(sock,&amp;amp;fds)) <span class="comment">//测试sock是否可读，即是否网络上有数据</span></div><div class="line">            &#123;</div><div class="line">                recvfrom(sock,buffer,<span class="number">256</span>,.....);<span class="comment">//接受网络数据</span></div><div class="line">                <span class="keyword">if</span>(FD_ISSET(fp,&amp;amp;fds)) <span class="comment">//测试文件是否可写</span></div><div class="line">                fwrite(fp,buffer...);<span class="comment">//写入文件</span></div><div class="line"> ......</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll函数类似于 select，可用于任何类型的文件描述符，与 select 不同，poll不是为每个状态（可读性、可写性和异常状态）构造一个描述符集，而是构造一个pollfd 结构数组向内核传递需要关注的事件，故没有描述符个数的限制，每个数组元素指定一个描述符编号以及对其所关心的状态，pollfd中的events字段和revents字段分别用于标示关注的事件和发生的事件。</p>
<p>poll的实现机制与select类似，其对应内核中的sys_poll，只不过poll向内核传递pollfd数组，然后对pollfd中的每个描述符进行poll，poll返回后，需要对pollfd中的每个元素检查其revents值，来判断事件是否发生。</p>
<p>返回值：</p>
<p>-1：有错误产生<br>0：超时时间到，而且没有描述符有状态变化<br>大于0：有状态变化的描述符个数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd fdarray[],<span class="keyword">nfds_t</span> nfds,<span class="keyword">int</span> timeout)</span></span>;</div><div class="line"><span class="keyword">struct</span> pollfd&#123;</div><div class="line">    <span class="keyword">int</span> fd; <span class="comment">//需要检查的文件描述符</span></div><div class="line">    <span class="keyword">short</span> events; <span class="comment">//等待的需要测试事件</span></div><div class="line">    <span class="keyword">short</span> revents; <span class="comment">//实际发生了的事件，也就是返回结果</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>应将每个数组元素的events成员设置为下图所示的值。通过这些值告诉内核我们对该描述符关心的是什么。返回时，内核设置revents成员，以说明对于该描述符已经发生了什么事件。（注意，poll没有更改events成员，这与select不同，select修改其参数以指示哪一个描述符已准备好了。）</p>
<p>timeout == -1 永远等待。当所指定的描述符中的一个已准备好，或捕捉到一个信号时则返回。如果捕捉到一个信号，则poll返回-1，errno设置为EINTR timeout == 0 不等待 timeout &gt; 0 等待timeout毫秒，如果已超时但是还没有一个描述符准备好，则返回值是0。</p>
<p>运行流程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> pollfd fds[IN_FILES];</div><div class="line"><span class="keyword">char</span> buf[MAX_BUFFER_SIZE];</div><div class="line"><span class="keyword">int</span> i,res,real_read, maxfd;</div><div class="line">fds[<span class="number">0</span>].fd = <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>((fds[<span class="number">1</span>].fd=open(&amp;quot;data1&amp;quot;,O_RDONLY|O_NONBLOCK)) &amp;lt; <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,&amp;quot;open data1 error:%s&amp;quot;,strerror(errno));</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>((fds[<span class="number">2</span>].fd=open(&amp;quot;data2&amp;quot;,O_RDONLY|O_NONBLOCK)) &amp;lt; <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,&amp;quot;open data2 error:%s&amp;quot;,strerror(errno));</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &amp;lt; IN_FILES; i++)</div><div class="line">&#123;</div><div class="line">    fds[i].events = POLLIN;</div><div class="line">&#125;</div><div class="line"><span class="keyword">while</span>(fds[<span class="number">0</span>].events || fds[<span class="number">1</span>].events || fds[<span class="number">2</span>].events)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (poll(fds, IN_FILES, TIME_DELAY) &amp;lt;= <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(&amp;quot;Poll error\n&amp;quot;);</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&amp;lt; IN_FILES; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (fds[i].revents)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, MAX_BUFFER_SIZE);</div><div class="line">            real_read = read(fds[i].fd, buf, MAX_BUFFER_SIZE);</div><div class="line">            <span class="keyword">if</span> (real_read &amp;lt; <span class="number">0</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span> (errno != EAGAIN)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!real_read)</div><div class="line">            &#123;</div><div class="line">                close(fds[i].fd);</div><div class="line">                fds[i].events = <span class="number">0</span>;</div><div class="line">            ......</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll通过epoll_create创建一个用于epoll轮询的描述符，通过epoll_ctl添加/修改/删除事件，通过epoll_wait 检查事件，epoll_wait 的第二个参数用于存放结果。</p>
<p>epoll与select、poll不同，首先，其不用每次调用都向内核拷贝事件描述信息，在第一次调用后，事件信息就会与对应的epoll描述符关联起来。另外epoll不是通过轮询，而是通过在等待的描述符上注册回调函数，当事件发生时，回调函数负责把发生的事件存储在就绪事件链表中，最后写到用户空间。</p>
<p>epoll返回后，该参数指向的缓冲区中即为发生的事件，对缓冲区中每个元素进行处理即可，而不需要像poll、select那样进行轮询检查。</p>
<p>系统调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</div><div class="line"><span class="comment">/*</span></div><div class="line">epoll的事件注册函数，它与select()是在监听事件时告诉内核要监听什么类型的事件不同，而是在这里先注册要监听的事件类型。第一个参数是epoll_create()的返回值，第二个参数表示动作，用三个宏来表示：</div><div class="line">EPOLL_CTL_ADD：注册新的fd到epfd中；</div><div class="line">EPOLL_CTL_MOD：修改已经注册的fd的监听事件；</div><div class="line">EPOLL_CTL_DEL：从epfd中删除一个fd；</div><div class="line">第三个参数是需要监听的fd，第四个参数是告诉内核需要监听什么事。</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</div><div class="line"><span class="keyword">struct</span> epoll_event结构如下：</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</div><div class="line">    <span class="keyword">void</span> *ptr;</div><div class="line">    <span class="keyword">int</span> fd;</div><div class="line">    <span class="keyword">__uint32_t</span> u32;</div><div class="line">    <span class="keyword">__uint64_t</span> u64;</div><div class="line">&#125; <span class="keyword">epoll_data_t</span>;</div><div class="line"><span class="keyword">struct</span> epoll_event</div><div class="line">&#123;</div><div class="line">    <span class="keyword">__uint32_t</span> events; <span class="comment">//Epoll events</span></div><div class="line">    <span class="keyword">epoll_data_t</span> data; <span class="comment">//User data variable</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>events可以是以下几个宏的集合：<br>EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；<br>EPOLLOUT：表示对应的文件描述符可以写；<br>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；<br>EPOLLERR：表示对应的文件描述符发生错误；<br>EPOLLHUP：表示对应的文件描述符被挂断；<br>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。<br>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里<br>运行流程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &amp;lt; nfds; ++n) &#123;</div><div class="line">    <span class="keyword">if</span> (events[n].data.fd == listener) &#123; <span class="comment">// 如果是主socket的事件的话，则表示</span></div><div class="line">    <span class="comment">// 有新连接进入了，进行新连接的处理。</span></div><div class="line">    client = accept(listener, (<span class="keyword">struct</span> sockaddr *) &amp;amp;local, &amp;amp;addrlen);</div><div class="line">    <span class="keyword">if</span> (client &amp;lt; <span class="number">0</span>)&#123;</div><div class="line">    perror(&amp;quot;accept&amp;quot;);</div><div class="line">    <span class="keyword">continue</span>;</div><div class="line">&#125;</div><div class="line">setnonblocking(client); <span class="comment">// 将新连接置于非阻塞模式</span></div><div class="line">ev.events = EPOLLIN | EPOLLET; <span class="comment">// 并且将新连接也加入EPOLL的监听队列。</span></div><div class="line"><span class="comment">// 注意，这里的参数EPOLLIN | EPOLLET并没有设置对写socket的监听，</span></div><div class="line"><span class="comment">// 如果有写操作的话，这个时候epoll是不会返回事件的，如果要对写操作</span></div><div class="line"><span class="comment">// 也监听的话，应该是EPOLLIN | EPOLLOUT | EPOLLET</span></div><div class="line">ev.data.fd = client;</div><div class="line"><span class="keyword">if</span> (epoll_ctl(kdpfd, EPOLL_CTL_ADD, client, &amp;amp;ev) &amp;lt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// 设置好event之后，将这个新的event通过epoll_ctl加入到epoll的监听队列里面，</span></div><div class="line">    <span class="comment">// 这里用EPOLL_CTL_ADD来加一个新的epoll事件，通过EPOLL_CTL_DEL来减少一个</span></div><div class="line">    <span class="comment">// epoll事件，通过EPOLL_CTL_MOD来改变一个事件的监听方式。</span></div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, &amp;quot;epoll <span class="built_in">set</span> insertion error: fd=%d0, client);</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (event[n].events &amp;amp; EPOLLIN) &#123; <span class="comment">// 如果是已经连接的用户，并且收到数据，</span></div><div class="line">    <span class="comment">// 那么进行读入</span></div><div class="line">    <span class="keyword">int</span> sockfd_r;</div><div class="line">    <span class="keyword">if</span> ((sockfd_r = event[n].data.fd) &amp;lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    read(sockfd_r, buffer, MAXSIZE);</div><div class="line">    <span class="comment">// 修改sockfd_r上要处理的事件为EPOLLOUT</span></div><div class="line">    ev.data.fd = sockfd_r;</div><div class="line">    ev.events = EPOLLOUT | EPOLLET;</div><div class="line">    epoll_ctl(epfd, EPOLL_CTL_MOD, sockfd_r, &amp;amp;ev)</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (event[n].events &amp;amp; EPOLLOUT) &#123; <span class="comment">// 如果有数据发送</span></div><div class="line">    <span class="keyword">int</span> sockfd_w = events[n].data.fd;</div><div class="line">    write(sockfd_w, buffer, <span class="keyword">sizeof</span>(buffer));</div><div class="line">    <span class="comment">// 修改sockfd_w上要处理的事件为EPOLLIN</span></div><div class="line">    ev.data.fd = sockfd_w;</div><div class="line">    ev.events = EPOLLIN | EPOLLET;</div><div class="line">    epoll_ctl(epfd, EPOLL_CTL_MOD, sockfd_r, &amp;amp;ev)</div><div class="line">&#125;</div><div class="line">    do_use_fd(events[n].data.fd);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>《UNIX环境高级编程》<br>《UNIX网络编程I卷》<br> <a href="http://armsword.com/2014/03/07/linux-io-multiplexing/" target="_blank" rel="external">http://armsword.com/2014/03/07/linux-io-multiplexing/</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/03/并发编程-多进程-IO复用-多线程/" itemprop="url">
                  并发编程之-多进程-I/O复用-多线程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-03T10:01:59+00:00" content="2016-07-03">
              2016-07-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/C-与linux网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">C++与linux网络编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/03/并发编程-多进程-IO复用-多线程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/03/并发编程-多进程-IO复用-多线程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自从入职百度以来，一直很忙，工作时间一直没有时间写博客，趁着周末又把深入理解操作系统重要章节看了一遍，对了部分知识有了更加深刻的理解，书真是要常读常新，久置易忘。下面分析总结下这三种常见并发编程方式：</p>
<h2 id="多进程echo服务器"><a href="#多进程echo服务器" class="headerlink" title="多进程echo服务器"></a>多进程echo服务器</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span></span>;</div><div class="line"><span class="comment">//事件处理函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="number">0</span>, WNOHANG) &gt; <span class="number">0</span>)</div><div class="line">    ;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h3><ol>
<li>服务器端打开一个socket<br>whil0e循环主体：</li>
<li>接受来自客户端的连接,返回一个已连接套接字符</li>
<li>fork初始化一个子进程,子进程提供服务</li>
<li>父进程关闭连接描述符<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> listenfd, connfd, port;</div><div class="line">    <span class="keyword">socklen_t</span> clientlen=<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</div><div class="line">    <span class="keyword">struct</span> sockaddr_in clientaddr;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    port = atoi(argv[<span class="number">1</span>]);</div><div class="line">    <span class="comment">// 根据信号编号调用事件处理函数</span></div><div class="line">    Signal(SIGCHLD, sigchld_handler);<span class="comment">//用于回收子进程资源-避免僵尸进程</span></div><div class="line">    listenfd = Open_listenfd(port);</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        connfd = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);</div><div class="line">        <span class="keyword">if</span> (Fork() == <span class="number">0</span>) &#123; </div><div class="line">            Close(listenfd); <span class="comment">/* 子进程关闭监听描述符 */</span></div><div class="line">            echo(connfd);    <span class="comment">/* echo服务 */</span> </div><div class="line">            Close(connfd);   <span class="comment">/* 子进程关闭连接描述符 */</span> </div><div class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);         <span class="comment">/* 子进程退出 */</span></div><div class="line">        &#125;</div><div class="line">        Close(connfd); <span class="comment">/* 父进程关闭连接描述符-很重要! */</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="I-O复用echo服务器"><a href="#I-O复用echo服务器" class="headerlink" title="I/O复用echo服务器"></a>I/O复用echo服务器</h2><p>select函数处理类型为fd_set的描述符集合，逻辑上把描述符集合看出换一个大小为n的位向量，select有两个输入，一个是读集合的描述符集合和该集合的基数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"csapp.h"</span></span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123; <span class="comment">/* 连接描述符池*/</span> </div><div class="line">    <span class="keyword">int</span> maxfd;        <span class="comment">/* 读集合的最大描述符 */</span>   </div><div class="line">    fd_set read_set;  <span class="comment">/* 所有活动描述符集合*/</span></div><div class="line">    fd_set ready_set; <span class="comment">/* 准备好读的描述符子集  */</span></div><div class="line">    <span class="keyword">int</span> nready;       <span class="comment">/* 从select中准备好读的描述符数量 */</span>   </div><div class="line">    <span class="keyword">int</span> maxi;         <span class="comment">/* highwater index into client arra */</span></div><div class="line">    <span class="keyword">int</span> clientfd[FD_SETSIZE];    <span class="comment">/* 活动描述符集 */</span></div><div class="line">    <span class="keyword">rio_t</span> clientrio[FD_SETSIZE]; <span class="comment">/* 活动读缓冲区集合 */</span></div><div class="line">&#125; pool; </div><div class="line"><span class="comment">//初始化连接池</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_pool</span><span class="params">(<span class="keyword">int</span> listenfd, pool *p)</span></span>;</div><div class="line"><span class="comment">//往pool添加客户端连接符</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_client</span><span class="params">(<span class="keyword">int</span> connfd, pool *p)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_clients</span><span class="params">(pool *p)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">int</span> byte_cnt = <span class="number">0</span>; <span class="comment">/* 计算从服务器接收的总字节*/</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> listenfd, connfd, port; </div><div class="line">    <span class="keyword">socklen_t</span> clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</div><div class="line">    <span class="keyword">struct</span> sockaddr_in clientaddr;</div><div class="line">    <span class="keyword">static</span> pool pool; </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    port = atoi(argv[<span class="number">1</span>]);</div><div class="line"></div><div class="line">    listenfd = Open_listenfd(port);</div><div class="line">    init_pool(listenfd, &amp;pool); <span class="comment">//初始化连接描述符池</span></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">    <span class="comment">/* 使用select等待监听描述符上的连接请求或来自标准输入上的命令 */</span></div><div class="line">    pool.ready_set = pool.read_set;</div><div class="line">    pool.nready = Select(pool.maxfd+<span class="number">1</span>, &amp;pool.ready_set, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* 当监听描述符准备好时，添加一个新的客户端已连接描述符到连接池 */</span></div><div class="line">    <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;pool.ready_set)) &#123; </div><div class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen); </div><div class="line">        add_client(connfd, &amp;pool); </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/* 从每个准备好的已连接描述符回送一行文本内容 */</span> </div><div class="line">    check_clients(&amp;pool); </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="多线程echo服务器"><a href="#多线程echo服务器" class="headerlink" title="多线程echo服务器"></a>多线程echo服务器</h2><p>###重要的几点</p>
<blockquote>
<ul>
<li>while循环中为何要动态分配一个整型来存放已连接描述符?</li>
<li>thread中Pthread_detach？</li>
</ul>
</blockquote>
<p>1.如果使用引用，由于线程竞争将导致意外结果，试想如果在下一次连接到来，thread例程函数中当前描述符变成下一次连接描述符<br>2.我们知道线程默认情况下被创建成可结合的，为了避免存储器泄漏(其资源如栈等)，每个结合线程要么被其他线程显式的收回，要么使用thread_detach被分离，待其终止由系统自动释放其资源，这样对于web程序而言是好的，因为web服务器每收到一个web浏览器的连接请求都创建一个对等线程，每个连接由一个单独的线程处理，没必要等也不愿意等到每个对等线程终止</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"csapp.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> listenfd, *connfdp, port;</div><div class="line">    <span class="keyword">socklen_t</span> clientlen=<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</div><div class="line">    <span class="keyword">struct</span> sockaddr_in clientaddr;</div><div class="line">    <span class="keyword">pthread_t</span> tid; </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    port = atoi(argv[<span class="number">1</span>]);</div><div class="line"></div><div class="line">    listenfd = Open_listenfd(port);</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        connfdp = Malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">//想想为啥不直接在Pthread_create使用引用参数</span></div><div class="line">        *connfdp = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen); </div><div class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, connfdp);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 一个线程例程 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span> </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">int</span> connfd = *((<span class="keyword">int</span> *)vargp);</div><div class="line">    Pthread_detach(pthread_self()); <span class="comment">//很重要，线程分离后才能在终止时由系统自动释放</span></div><div class="line">    Free(vargp);                   </div><div class="line">    echo(connfd);</div><div class="line">    Close(connfd);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>##方法优劣总结</p>
<h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>对于在父子进程间共享状态信息，进程有一个很清晰的模型，共享文件表不共享用户地址空间，这是优点又是缺点，一个是独立不会覆盖另一个进程的虚拟存储器，消除了许多令人迷惑的错误，另一方面使得进程间共享转态信息变的困难，共享信息-&gt;得通过IPC实现，开销高</p>
<h3 id="I-O复用"><a href="#I-O复用" class="headerlink" title="I/O复用"></a>I/O复用</h3><p>I/O复用不等价于并发事件驱动程序，但可以作为其基础，在并发事件驱动中，流是因为某个事件而前进的，逻辑流模型=》转态机，一个转态机由一组状态，输入事件和转移构成。<br><strong>优点</strong>：</p>
<blockquote>
<p>给了码农更多对于程序行为的控制，比如编写一个事件驱动的并发服务器，为某些客户端提供他们需要的服务，基于多进程是很困难，（redis的事件处理基于I/O复用）<br>运行在的单一进程上下文中，每个逻辑流都能访问该进程的全部地址空间，使得在流之间共享数据变的容易-便于调试</p>
</blockquote>
<p><strong>缺点</strong>:<br>编码复杂，代码量大，随着并发粒度见笑，复杂性-上升迅速</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>结合上述两者的特性，在执行模型上既有着类似多进程的多线程内核自动调度，又有着I/O复用流享用的共享整个虚拟地址空间的整个内容<br>线程是运行在进程上下文中的逻辑流，线程由内核自动调度，每个线程有她自己的线程上下文，包括Thread ID,栈，栈指针，程序计数器，通用目的寄存器和条件码，共享进程的整个虚拟地址空间</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/29/程序性能优化/" itemprop="url">
                  程序性能优化方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-29T20:20:59+00:00" content="2016-06-29">
              2016-06-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/性能优化/" itemprop="url" rel="index">
                    <span itemprop="name">性能优化</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/29/程序性能优化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/29/程序性能优化/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="程序性能优化"><a href="#程序性能优化" class="headerlink" title="程序性能优化"></a>程序性能优化</h1><p> 在深入理解os这本书中，在里面有一章是专门针对性能优化的，在高并发的系统中，程序性能直接关系到用户体验，一般来说用户容忍度总是非常低的，比如打开网页要求2s得到相应。</p>
<h2 id="是否可优化"><a href="#是否可优化" class="headerlink" title="是否可优化"></a>是否可优化</h2><p>思考<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *xp, <span class="keyword">int</span> *yp)</span></span>&#123;</div><div class="line">	*xp = *xp + *yp;</div><div class="line">	*yp = *xp - *yp;</div><div class="line">	*xp = *xp - *yp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可否替换为<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *xp, <span class="keyword">int</span> *yp)</span></span>&#123;</div><div class="line">    *xp = *xp + *yp;</div><div class="line">    *yp = *xp - *yp;</div><div class="line">    *xp = *xp - *yp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>又如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">twiddle</span><span class="params">(<span class="keyword">int</span> *xp, <span class="keyword">int</span> *yp)</span> </span>&#123;</div><div class="line">	*xp += *yp;</div><div class="line">    *xp += *yp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可否替换为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">twiddle1</span><span class="params">(<span class="keyword">int</span> *xp, <span class="keyword">int</span> *yp)</span> </span>&#123;</div><div class="line">*xp = <span class="number">2</span>* (*yp);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实际上上面连个看起来是传进来了不同的参数，但是当参数相同的话，结果是不一样的，优化是错的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> f() + f() + f();&#125;</div></pre></td></tr></table></figure></p>
<p>可否替换为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">3</span>*f();&#125;</div></pre></td></tr></table></figure></p>
<p>这种情况下，当f调用了全局变量就会产生副作用，返回值也可能会不一样</p>
<h2 id="常用的优化方法"><a href="#常用的优化方法" class="headerlink" title="常用的优化方法"></a>常用的优化方法</h2><h3 id="1-在循环中减少函数调用"><a href="#1-在循环中减少函数调用" class="headerlink" title="1.在循环中减少函数调用"></a><strong>1.在循环中减少函数调用</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Implementation of library function strlen */</span></div><div class="line"> <span class="comment">/* Compute length of string */</span></div><div class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span> *s)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> length = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span> (*s != ’\<span class="number">0</span>’) &#123;</div><div class="line">		s++;</div><div class="line">		length++;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> length;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lower1</span><span class="params">(<span class="keyword">char</span> *s)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)&#123;</div><div class="line">		<span class="keyword">if</span> (s[i] &gt;= ’A’ &amp;&amp; s[i] &lt;= ’Z’)</div><div class="line">		s[i] -= (’A’ - ’a’);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将strlen(s)从循环中外提</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lower1</span><span class="params">(<span class="keyword">char</span> *s)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(s); <span class="comment">//循环中调用外提</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)&#123;</div><div class="line">		<span class="keyword">if</span> (s[i] &gt;= ’A’ &amp;&amp; s[i] &lt;= ’Z’)</div><div class="line">		s[i] -= (’A’ - ’a’);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-消除不必要的存储器引用"><a href="#2-消除不必要的存储器引用" class="headerlink" title="2.消除不必要的存储器引用"></a><strong>2.消除不必要的存储器引用</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine</span><span class="params">(vec_ptr v, <span class="keyword">data_t</span> *dest)</span></span></div><div class="line"> &#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">int</span> length = vec_length(v); </div><div class="line">	*dest = IDENT; </div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">		<span class="keyword">data_t</span> val;</div><div class="line">		get_vec_element(v, i, &amp;val);</div><div class="line">		*dest = *dest OPER val;  </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在每次循环中减少中间过程读写<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Accumulate result in local variable */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine4</span><span class="params">(vec_ptr v, <span class="keyword">data_t</span> *dest)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">int</span> length = vec_length(v);</div><div class="line">	<span class="keyword">data_t</span> *data = get_vec_start(v); <span class="comment">//</span></div><div class="line">	<span class="keyword">data_t</span> x = IDENT;</div><div class="line">	*dest = IDENT;</div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">		x = x OPER data[i]; <span class="comment">//循环内相除存储器引用</span></div><div class="line">	&#125;</div><div class="line">	*dest = x;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-循环展开"><a href="#3-循环展开" class="headerlink" title="3.循环展开"></a><strong>3.循环展开</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">vsum1</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">    c[i] = a[i] + b[i];</div><div class="line"> &#125;</div><div class="line">循环展开为</div><div class="line">``` C++</div><div class="line"><span class="comment">/* Sum vector of n elements (n must be even) */</span></div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">vsum2</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line"> &#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i+=<span class="number">2</span>) &#123;</div><div class="line">         <span class="comment">/* Compute two elements per iteration */</span></div><div class="line">        c[i] = a[i] + b[i];</div><div class="line">        c[i+<span class="number">1</span>] = a[i+<span class="number">1</span>] + b[i+<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="4-提高并行性"><a href="#4-提高并行性" class="headerlink" title="4.提高并行性"></a><strong>4.提高并行性</strong></h3><p>使用多个临时变量，只在必要的时候将多个临时变量合并</p>
<h3 id="5-重新结合变换"><a href="#5-重新结合变换" class="headerlink" title="5.重新结合变换"></a><strong>5.重新结合变换</strong></h3><p>acc = (acc OP data[i]) OP data[i+1];<br>每次迭代都要求前一次迭代必须结束才能开始，因为第一个操作就要求读取acc的值．<br>acc = acc OP (data[i] OP data[i+1]);<br>修改后，下一次迭代的开始可以先于当前迭代的结束，因为下一次迭代可以先计算data[i] OP data[i+1]这个操作．</p>
<h2 id="阿姆达尔定律"><a href="#阿姆达尔定律" class="headerlink" title="阿姆达尔定律"></a>阿姆达尔定律</h2><p>阿姆达尔定律是计算机系统设计的重要定量原理之一，于1967年由IBM360系列机的主要设计者阿姆达尔首先提出。该定律是指：系统中对某一部件采用更快执行方式所能获得的系统性能改进程度，取决于这种执行方式被使用的频率，或所占总执行时间的比例。阿姆达尔定律实际上定义了采取增强（加速）某部分功能处理的措施后可获得的性能改进或执行时间的加速比。简单来说是通过更快的处理器来获得加速是由慢的系统组件所限制。<br>阿姆达尔曾致力于并行处理系统的研究。对于固定负载情况下描述并行处理效果的加速比s，阿姆达尔经过深入研究给出了如下公式：<br>$$S=1/(1-a+a/n)$$<br>其中，a为并行计算部分所占比例，n为并行处理结点个数。这样，当1-a=0时，(即没有串行，只有并行)最大加速比s=n；当a=0时（即只有串行，没有并行），最小加速比s=1；当n→∞时，极限加速比s→ 1/（1-a），这也就是加速比的上限。例如，若串行代码占整个代码的25%，则并行处理的总体性能不可能超过4。这一公式已被学术界所接受，并被称做“阿姆达尔定律”，也称为“安达尔定理”(Amdahl law)。</p>
<h2 id="C-C-中的优化"><a href="#C-C-中的优化" class="headerlink" title="C/C++中的优化"></a>C/C++中的优化</h2><blockquote>
<ul>
<li><strong>如字符串初始化使用 str[‘\0’] (避免使用memeset)</strong></li>
<li><strong>char buffer[1024] = {100} 会调用memset, 可以改为:</strong><br>char buffer[1024];<br>buffer[0] = 100</li>
<li><strong>选择正确的数据结构，正确选择stl的容器</strong><ul>
<li>数据量大时可以使用std::str1 或boost中 unordered_set/map 替代<br>map/set, 前者基于hash实现, 后者基于rb tree实现</li>
<li>std::list 求长度 O(n)</li>
<li>STL 的容器用完或者使用前记得reset, 否则会膨胀, 类似内存泄漏<br>reset 并没真正释放内存, 可能只是修改了长度和指针位置</li>
<li>尽量使用std::sort, 而不是自写排序</li>
<li>使用reverse 避免不必要的内存重分配</li>
<li>去重和查找尽量用hashmap 而不是 vector + find</li>
</ul>
</li>
<li><strong>避免重复申请内存</strong><ul>
<li>用可重复初始化对象, 代替每次都new</li>
<li>重复多次申请小块内存, 可以自己实现简单的buffer管理器</li>
<li>使用tcmalloc ?</li>
</ul>
</li>
<li><strong>多线程</strong><ul>
<li>多线程的调度, 让 IO 和 CPU计算 相互重叠，降低<br>latency</li>
<li>能提高绝对性能, 但是平均性能提升明显</li>
</ul>
</li>
<li><strong>openmp让循环中可以并行的部分得到并行处理</strong><ul>
<li>o 打开编译选项 -fopenmp</li>
</ul>
</li>
<li><strong>按字节固定初始有时可使用memeset,比for循环快很多</strong><ul>
<li>测试过1亿字符串统一赋值，用memeset比for循环赋值快10倍</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>&lt;&lt;深入理解操作系统&gt;&gt;<br>&lt;&lt;大牛分享&gt;&gt;</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/16/网络爬虫总结/" itemprop="url">
                  爬虫总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-16T10:01:59+00:00" content="2016-06-16">
              2016-06-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/C-与linux网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">C++与linux网络编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/16/网络爬虫总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/16/网络爬虫总结/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在校期间由于到时I数据需求以及自己偶尔倒腾，写过一段时间爬虫，爬过csdn博客,天涯论坛,sina博客,sina微公益，学校就业系统数据(当时基本把全院就业数据爬下来了，包括每个人的身份证家庭住址联系方式就业去向等信息)等等,也爬过主流网站的信息当时想着做了一个粗糙的小型搜索引擎.在实习阶段写过一段时间爬虫系统，此时就主要用的scrapy框架了，爬取了7个主流手游网站游戏资讯论坛的信息.一直没有空去总结下,趁着有空总结下基本技巧</p>
<h2 id="关于爬取的三个方面"><a href="#关于爬取的三个方面" class="headerlink" title="关于爬取的三个方面"></a>关于爬取的三个方面</h2><h3 id="网络爬虫归根结底是如何拿到服务器数据"><a href="#网络爬虫归根结底是如何拿到服务器数据" class="headerlink" title="网络爬虫归根结底是如何拿到服务器数据"></a>网络爬虫归根结底是如何拿到服务器数据</h3><p>在你分析完目标站点的需要的数据之后,思考如何爬取过程自动化，一般站点的数据组织方式都是有规律，比如csdn会有一个所有博客的一个汇总存档页，如果你需要爬取所有的页面博客，你需要分析第1页到第n页的页面连接url规律,然后依次请求每页数据，得到每个页的几十个博客url，下层进行每个url的深入爬取。</p>
<h3 id="如果你写过爬虫-你会在拿数据的过程会遇到各种各样的问题，这里做一个罗列-总结下遇到的问题以及别人总结的一些问题"><a href="#如果你写过爬虫-你会在拿数据的过程会遇到各种各样的问题，这里做一个罗列-总结下遇到的问题以及别人总结的一些问题" class="headerlink" title="如果你写过爬虫,你会在拿数据的过程会遇到各种各样的问题，这里做一个罗列,总结下遇到的问题以及别人总结的一些问题"></a>如果你写过爬虫,你会在拿数据的过程会遇到各种各样的问题，这里做一个罗列,总结下遇到的问题以及别人总结的一些问题</h3><blockquote>
<p>数据是ajax请求的数据，请求方式不反应在链接上<br>数据在请求过程受到服务器频次限制,ip被封|频次限制<br>数据需要登录才能抓取数据<br>数据是js解析后才能拿到<br>部分网站不管你头部具体内容是什么，总是得到gzip后的内容<br>服务器加上了防盗链的限制<br>服务器加了限制，只让常见浏览器访问<br>url请求时加了编码信息<br>https以及http爬取<br>验证码问题<br>url如何判重<br>数据编码问题以及请求参数编码</p>
</blockquote>
<h3 id="大型搜索引擎爬取问题"><a href="#大型搜索引擎爬取问题" class="headerlink" title="大型搜索引擎爬取问题"></a>大型搜索引擎爬取问题</h3><blockquote>
<p>在真实的大型爬虫系统中(比如百度),如何保证保证覆盖率，更新率，实效性，有效性<br>标准：全、快、准、新<br>覆盖率：链接是否已发现，网页是否已抓取<br>更新率：网页发生变化或失效后是否最大限度地发现并更新<br>时效性：新网页（时效性较高的网页）产生或网页发生变化后，是否及时发现、抓取、更新。<br>有效性：可以分为抓取有效性和存储有效性。<br>1）抓取有效性：是指抓取流量中有多少是抓取了有价值的东西，对CHK来说就是得到了新的链接，对GET抓回来了能建库的网页就是有效的。<br>2）存储有效性：是指主要是指节省link库和网页库的空间。如果存储了大量低质量的那有效性就不高。</p>
</blockquote>
<h3 id="上面的问题的一些解决方法"><a href="#上面的问题的一些解决方法" class="headerlink" title="上面的问题的一些解决方法"></a>上面的问题的一些解决方法</h3><p><strong> 数据是ajax请求的数据，请求方式不反应在链接上</strong><br>打开浏览器解析，分析ajax的真实请求url的规律，分析请求参数，分析结果json<br>按照实际url和参数请求<br><strong> 数据在请求过程受到服务器频次限制,ip被封|频次限制 </strong><br>使用代理IP服务器,scrapy有一个专门IP代理池<br>再一个可以使用sleep限制程序降低爬取频次<br>技术做的特别好的，封的厉害的需要获取开发者权限,token之类的</p>
<p><strong> 数据需要登录才能抓取数据 </strong><br>使用import urllib.request<br>并用用字典封装post键值对作为open方法的参数，包括用户名密码等必要参数</p>
<p><strong> 数据是js解析后才能拿到 </strong><br>使用selenium、phantomjs等模拟浏览器引擎构建一个真实的浏览器执行JS<br>百度也是有专门的解析器sunflower的，Sunflower采用firefox浏览器的mozilla内核，本质上就是把firefox的必要部分组装起来，得到一个同浏览器比较相似的抓取器，能够得到页面在浏览器实际展现时候的完整数据。它能够像浏览器一样处理html页面，包括js，css，xmlrequest</p>
<p><strong> 部分网站不管你头部具体内容是什么，总是得到gzip后的内容</strong><br>使用import gzip相应方法解压,重点要知道是有得到压缩数据情况</p>
<p><strong> 服务器加上了防盗链的限制 </strong><br>某些站点有反盗链设置，其实就是检查你发送请求的header里面，referer站点是不是他自己，我们只要把headers的referer改成该网站即可<br><strong> 服务器加了限制，只让常见浏览器访问</strong><br>请求时加上浏览器头部，伪装成浏览器<br><strong> url请求时加了编码信息 </strong><br>使用urllib.quote(‘’)</p>
<p><strong> https以及http爬取 </strong><br>https是加密传输，其实用scrapy爬取并没什么不一样</p>
<p><strong> 验证码问题　</strong><br>图像识别？训练好相应图片验证码模型，不过有些事要计算或者推理的，比较难</p>
<p><strong> url如何判重 </strong><br>判重需要节省内存，一般使用布隆过滤器，在数学之美中有提到过</p>
<p><strong> 大型搜索引擎爬取问题 </strong><br>入职百度以来看了爬虫相关文档,发现设计考虑问题还是非常多的，有空再总结下<br>相关重要问题，不涉及具体实现</p>
<h3 id="拿到数据之后剩余的问题就是如何解析拿到想要的数据入库"><a href="#拿到数据之后剩余的问题就是如何解析拿到想要的数据入库" class="headerlink" title="拿到数据之后剩余的问题就是如何解析拿到想要的数据入库."></a>拿到数据之后剩余的问题就是如何解析拿到想要的数据入库.</h3><p>这里主要分为两块:<br><strong>首页如何提取html页面想要的信息</strong></p>
<p>解析html可以使用BeautifulSoup和xpath,有很多解析tag的方法,比起正则使用起来方便容易很多,常用的findall,find,find_next,find_parent,get_text()等等，这里不详细描述<br>参看官方文档,<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" target="_blank" rel="external">https://www.crummy.com/software/BeautifulSoup/bs4/doc/</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</div></pre></td></tr></table></figure></p>
<p>当然也可以自己实现,百度就是自己C实现了解析的基础库</p>
<p><strong>怎么存储</strong><br>数据量小可以直接按表格形式存入excel<br>推荐两个python包<br>import xlwt3<br>from xlrd import open_workbook<br>数据量大,使用mysql数据库或者本地文件</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/11/布隆过滤器/" itemprop="url">
                  布隆过滤器浅谈
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-11T20:41:56+00:00" content="2016-06-11">
              2016-06-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Data-structure-and-Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Data structure and Algorithm</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/11/布隆过滤器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/11/布隆过滤器/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><h2 id="之前就阅读过数学之美，知道有这么个基础的算法，可是因为不常用到也就没当回事，最近重新看到它觉得很高大上，就想来mark下"><a href="#之前就阅读过数学之美，知道有这么个基础的算法，可是因为不常用到也就没当回事，最近重新看到它觉得很高大上，就想来mark下" class="headerlink" title="之前就阅读过数学之美，知道有这么个基础的算法，可是因为不常用到也就没当回事，最近重新看到它觉得很高大上，就想来mark下"></a>之前就阅读过数学之美，知道有这么个基础的算法，可是因为不常用到也就没当回事，最近重新看到它觉得很高大上，就想来mark下</h2><p>设计初衷：<br>（Bloom Filter）是由布隆（Burton Howard Bloom）在1970年提出的，不知道当时布隆为啥想到设计时究竟是碰到了啥问题，但这确实很有效<br><strong>来看下面的问题：<br>1.检查一个单词是否拼写正确-&gt;看它是否在已经字典中<br>2.网络爬虫-&gt;一个网址是否访问过<br>3.邮件过滤，建立那些发垃圾邮件的地址的黑名单</strong></p>
<p><strong>你可能会说哈希表不就行了吗，但在2,3的问题中，网页和垃圾邮件地址全球动不动便是几十亿那，哈希的存储效率也就50%左右</strong><br>    一亿Email（一个占16字节）约为1.6GB内存，要是几十亿个地址就几百GB，需要耗费很大代码<br>所以啊，能不能少花点内存来干这事：于是布隆过滤器来了，只要12.5%到25%的哈希表空间就能干这事，但是有点小错误，这个小错误概率太小就基本不担心了</p>
<p>工作原理：<br>一亿Email =&gt; 16亿二进制（bit)==2亿字节（哈希就是16亿字节了）</p>
<h3 id="1-先全部位清0，对每一个电子邮件地址X，用8个不同的随机数产生器（F1，F2，-F8-产生8个信息指纹（比如md5"><a href="#1-先全部位清0，对每一个电子邮件地址X，用8个不同的随机数产生器（F1，F2，-F8-产生8个信息指纹（比如md5" class="headerlink" title="1.先全部位清0，对每一个电子邮件地址X，用8个不同的随机数产生器（F1，F2，..F8)产生8个信息指纹（比如md5),"></a>1.先全部位清0，对每一个电子邮件地址X，用8个不同的随机数产生器（F1，F2，..F8)产生8个信息指纹（比如md5),</h3><p>###2.然后用一个统一的随机数产生器G把这8个信息指纹=&gt;8个自然数g1,g2,g3..,g8,这些位置上的位置为1</p>
<p>1亿个地址放入建好这个布隆过滤器</p>
<p>然后新来一个，同样处理，对应8个二进制位 t1,t2,…,t8<br>如果全为1，好的=&gt;判定位垃圾邮件</p>
<p>你会想了，这样靠谱不，万一把非垃圾邮件误判了咋办</p>
<p>我们来看看误判的概率：<br>先来算任何一个位被置为1的概率p，这样你可以简单的就知道<br>新来一个，有8个位，如果被误判了，此时这8个位全为1，其概率为$$p^8$$<br>我们来推到下一般的情况，假设有m个位，n个元素，有k个哈希函数，<br>针对单个元素插入来说：<br>$$任一个位被置为1的概率：1/m$$<br>$$K个函数都没有把它置为1：（1-1/m)^k$$<br>$$插入了那个元素依然没有被置为1：（1-1/m)^{kn}$$<br>$$反过来说，一个位被置为1：1-（1-1/m)^{kn}$$<br>同样的新来一个，要命中其概率为：<br>$1-[1-1/m]^{kn})^k 近似（1-e^{-kn/m})^k$<br>上次k=8,n/m=1/16,计算值大约在万分之五，误判率非常低，基本可容忍。*</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/11/一个小C++程序内存泄漏检测/" itemprop="url">
                  C++内存泄漏以及检测
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-11T01:01:59+00:00" content="2016-06-11">
              2016-06-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/C-与linux网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">C++与linux网络编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/11/一个小C++程序内存泄漏检测/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/11/一个小C++程序内存泄漏检测/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>c++一般采用malloc/free或new/delete来动态分配和释放内存<br>二者有何不同？malloc/free是C/C++语言的标准库函数，new/delete是C++的运算符<br>malloc/free以及new/delete一般是配对出现，如果malloc后没有free，或者new后没有delete都将造成内存泄漏</p>
<p>##一个小例子来说明内存泄漏<br>例子1<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们用valgrind工具来检测这段程序的内存泄漏情况</p>
<div align="center"><br><img src="/img/leak1.jpg" alt="^_^||"><br></div>


<p>例2 我们正确的进行释放<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</div><div class="line">    <span class="keyword">delete</span> []p;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们用valgrind工具来检测这段程序的内存泄漏情况</p>
<div align="center"><br><img src="/img/leak2.jpg" alt="^_^||"><br></div>


<p>例3 我们用delete p来代替delete []p;<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</div><div class="line">    <span class="keyword">delete</span> p;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们用valgrind工具来检测这段程序的内存泄漏情况</p>
<div align="center"><br><img src="/img/leak3.jpg" alt="^_^||"><br></div>

<p>从valgrind上我们可以看到，delete p和delete []p都没有造成内存泄漏，进行了全部内存的释放<br>但对与delete p用法valgrind明显的抛出了free/delete不匹配的提醒<br>其实按照正常逻辑推理，应该delete p只是释放了首地址元素的内存，应该会造成内存泄漏，而事实上<br>两种方式并未造成内存泄漏，这里尚有些疑问。</p>
<h2 id="malloc-free-与-new-free-的比较"><a href="#malloc-free-与-new-free-的比较" class="headerlink" title="malloc/free 与 new/free 的比较"></a>malloc/free 与 new/free 的比较</h2><h3 id="各自用法"><a href="#各自用法" class="headerlink" title="各自用法"></a>各自用法</h3><p>函数malloc 的原型如下：<br>void <em> malloc(size_t size);<br>用malloc 申请一块长度为length 的整数类型的内存，程序如下：<br>int </em>p = (int <em>) malloc(sizeof(int) </em> length);<br>我们应当把注意力集中在两个要素上：“类型转换”和“sizeof”<br>1、malloc 返回值的类型是void <em>，所以在调用malloc 时要显式地进行类型转换，将void </em> 转换成所需要的指针类型。<br>2、 malloc 函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。</p>
<p>函数free 的原型如下：<br>void free( void * memblock );<br>为什么free 函数不象malloc 函数那样复杂呢？这是因为指针p 的类型以及它所指的内存的容量事先都是知道的，语句free(p)能正确地释放内存。如果p 是NULL 指针，那么free对p 无论操作多少次都不会出问题。如果p 不是NULL 指针，那么free 对p连续操作两次就会导致程序运行错误。</p>
<p>运算符new 使用起来要比函数malloc 简单得多，例如：<br>int <em>p1 = (int </em>)malloc(sizeof(int) <em> length);<br>int </em>p2 = new int[length];<br>这是因为new内置了sizeof、类型转换和类型安全检查功能。对于非内部数据类型的对象而言，new 在创建动态对象的同时完成了初始化工作。如果对象有多个构造函数，那么new 的语句也可以有多种形式。<br>如果用new 创建对象数组，那么只能使用对象的无参数构造函数。例如<br>Obj <em>objects = new Obj[100];       // 创建100 个动态对象<br>不能写成<br>(x)Obj </em>objects = new Obj<a href="1">100</a>;        // 创建100 个动态对象的同时赋初值1<br>在用delete 释放对象数组时，留意不要丢了符号‘[]’。例如<br>delete []objects; // 正确的用法<br>delete objects; // 错误的用法</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><blockquote>
<p>1.new自动计算需要分配的空间，而malloc需要手工计算字节数<br>2、new是类型安全的，而malloc不是，比如：<br>                 int<em> p = new float[2]; // 编译时指出错误<br>                 int</em> p = malloc(2*sizeof(float)); // 编译时无法指出错误<br>3.new operator 由两步构成，分别是 operator new 和 construct,operator new对应于malloc，但operator new可以重载，可以自定义内存分配策略，甚至不做内存分配，甚至分配到非内存设备上。而malloc无能为力<br>4.new将调用constructor，而malloc不能；delete将调用destructor，而free不能<br>5.malloc/free要库文件支持，new/delete则不要。 </p>
</blockquote>
<p><strong>malloc/free是C/C++语言的标准库函数，new/delete是C++的运算符。<br>对于用户自定义的对象而言，用maloc/free无法满足动态管理对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>valgrind的使用<br><a href="http://blog.csdn.net/justdoithai/article/details/52347676" target="_blank" rel="external">http://blog.csdn.net/justdoithai/article/details/52347676</a><br><a href="http://blog.csdn.net/hackbuteer1/article/details/6789164" target="_blank" rel="external">http://blog.csdn.net/hackbuteer1/article/details/6789164</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/home.jpg"
               alt="xiegonghai" />
          <p class="site-author-name" itemprop="name">xiegonghai</p>
          <p class="site-description motion-element" itemprop="description">while(question)just thinking;</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="https://xiegonghai.github.io/archives/">
              <span class="site-state-item-count">24</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="https://xiegonghai.github.io/categories/">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/justdoithai" title="我的csdn博客" target="_blank">我的csdn博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.cplusplus.com/reference/algorithm" title="C++标准库" target="_blank">C++标准库</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://github.com/xiegonghai" title="我的github" target="_blank">我的github</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://net.pku.edu.cn/~yhf/linux_c/" title="linux_C函数" target="_blank">linux_C函数</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://man.linuxde.net/" title="linux命令" target="_blank">linux命令</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://tool.oschina.net/" title="Tools" target="_blank">Tools</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiegonghai</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"doit"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
