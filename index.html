<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Xiegonghai's Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="while(question)just thinking;">
<meta property="og:type" content="website">
<meta property="og:title" content="Xiegonghai's Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Xiegonghai's Blog">
<meta property="og:description" content="while(question)just thinking;">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Xiegonghai's Blog">
<meta name="twitter:description" content="while(question)just thinking;">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> Xiegonghai's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Xiegonghai's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">梦想还是要有的</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/29/redis中跳表分析(vs红黑树)/" itemprop="url">
                  redis中跳表实现(vs红黑树)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-29T17:38:59+08:00" content="2016-07-29">
              2016-07-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Redis学习/" itemprop="url" rel="index">
                    <span itemprop="name">Redis学习</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/29/redis中跳表分析(vs红黑树)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/29/redis中跳表分析(vs红黑树)/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 用过sorted set的话，都知道sorted set是redis非常首欢迎的数据结构，Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。<br> 而sorted set的底层实现便是skiplist,支持平均O(n)，最坏O(n)的查找时间复杂度</p>
<h2 id="跳表与红黑树"><a href="#跳表与红黑树" class="headerlink" title="跳表与红黑树?"></a>跳表与红黑树?</h2><p>虽然我们知道redis用skiplist用实现排序集,但了解过C++ STL的源码实现相关资料就会产生疑问,类似于redis的sorted set，STL的set,multiset,map,multimap底层均采用的RB-tree这里,这里skiplist与RB-Tree究竟有啥不一样,作者为何采用skiplist,它们有什么优缺点?在并行编程与利用并行硬件方面其特性表现如何？</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树是一种平衡二叉搜索树，自动排序效果不错，可在平均时间复杂度O(logn)内完成查找，插入，删除等操作,其基本性质如下：<br>性质1. 节点是红色或黑色<br>性质2. 根是黑色<br>性质3. 所有叶子都是黑色（叶子是NIL节点）<br>性质4. 如果一个节点是红的，则它的两个儿子都是黑的<br>性质5. 从任一节点到其叶子的所有简单路径都包含相同数目的黑色节点。<br>关于红黑树插入删除的不同情况下树的调整可阅读STL源码解析。其实现过程还是非常繁杂的，而skiplist相对来说是比较简单的。</p>
<h2 id="skiplist结构定义"><a href="#skiplist结构定义" class="headerlink" title="skiplist结构定义"></a>skiplist结构定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplistNode &#123;</div><div class="line">    sds ele;  <span class="comment">//与C风格兼容的字符串,空间预分配,重新配策略防止缓存区溢出</span></div><div class="line">    <span class="keyword">double</span> score; <span class="comment">//节点分值</span></div><div class="line">    <span class="keyword">struct</span> zskiplistNode *backward; <span class="comment">//后退指针</span></div><div class="line">    <span class="keyword">struct</span> zskiplistLevel &#123;</div><div class="line">        <span class="keyword">struct</span> zskiplistNode *forward;<span class="comment">//前进指针</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span; <span class="comment">//跨度,记录两个节点之间的距离</span></div><div class="line">    &#125; level[];</div><div class="line">&#125; zskiplistNode;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplist &#123;</div><div class="line">    <span class="keyword">struct</span> zskiplistNode *header, *tail;<span class="comment">//指向跳跃表的头节点和尾节点</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;<span class="comment">//表中节点数量</span></div><div class="line">    <span class="keyword">int</span> level;<span class="comment">//节点中的最大层数</span></div><div class="line">&#125; zskiplist;</div></pre></td></tr></table></figure>
<h2 id="跳表的实现原理"><a href="#跳表的实现原理" class="headerlink" title="跳表的实现原理"></a>跳表的实现原理</h2><p>我们知道在一个单链有序表搜索的时候，查找成功的平均时间复杂度O(n+1/2)<br>从该有序表中搜索元素 &lt; 23, 43, 59 &gt; ，需要比较的次数分别为 &lt; 2, 4, 6 &gt;，总共比较的次数为 2 + 4 + 6 = 12 次</p>
<div align="center"><br><img src="/img/skiplist1.jpg"><br></div><br>如果我们把一些节点提取出来作为索引,发现搜索次数减少<br><div align="center"><br><img src="/img/skiplist2.jpg"><br></div><br>我们还可以再从一级索引提取一些元素出来，作为二级索引，变成如下结构<br><div align="center"><br><img src="/img/skiplist3.jpg"><br></div><br><strong>从中可以看出跳表的核心思想，其实是一种空间换时间的做法，通过每增加每个节点向前的指针，同时存储多层指针。跳跃列表是按层建造的。底层是一个普通的有序链表。每个更高层都充当下面列表的「快速跑道」，这里在层 i 中的元素按某个固定的概率 p (通常<br>为0.5或0.25)出现在层 i+1 中。平均起来，每个元素都在 1/(1-p) 个列表中出现, 而最高层的元素（通常是在跳跃列表前端的一个特殊的头元素）<br>在 O(log1/p n) 个列表中出现。我们知道红黑树充分利用了节点的索引性质来加速查找效率，跳表其实也含有这么一种思想在里面，充分利用节点索引</strong><br><br><div align="center"><br><img src="/img/skiplist4.jpg"><br></div>

<h2 id="skiplist基本实现"><a href="#skiplist基本实现" class="headerlink" title="skiplist基本实现"></a>skiplist基本实现</h2><h3 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">/* 创建一个skiplist */ </div><div class="line">zskiplist *zslCreate(void);</div><div class="line"></div><div class="line">/* 创建一个skiplist节点 */</div><div class="line">zskiplistNode *zslCreateNode(int level, double score, robj *obj)；</div><div class="line"></div><div class="line">/* 释放一个节点的内存 */</div><div class="line">void zslFreeNode(zskiplistNode *node);</div><div class="line"></div><div class="line">/* 释放整个skiplist */</div><div class="line">void zslFree(zskiplist *zsl);</div><div class="line"></div><div class="line">/* 插入一个节点 */</div><div class="line">zskiplistNode *zslInsert(zskiplist *zsl, double score, robj *obj);</div><div class="line"></div><div class="line">/* 删除一个节点，根据score删除 */</div><div class="line">int zslDelete(zskiplist *zsl, double score, robj *obj);</div><div class="line"></div><div class="line">/*这个函数是查询某个节点对应的排名,其实就是在跳表中位置*/</div><div class="line">unsigned long zslGetRank(zskiplist *zsl, double score, robj *o);  </div><div class="line"></div><div class="line">```</div></pre></td></tr></table></figure>
<h3 id="重要实现函数解析"><a href="#重要实现函数解析" class="headerlink" title="重要实现函数解析"></a>重要实现函数解析</h3><p>以下是插入操作的实现,先看个跳表整体详细结构图</p>
<p><div align="center"><br><img src="/img/skiplist.jpg"><br></div><br>看上图，我们知道跳表的插入实现和单链表的插入式类似的，只不过现在每个节点含有多层,非常需要找到每层对应的插入节点前后指针以及跨度<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Insert a new node in the skiplist. Assumes the element does not already</span></div><div class="line"> * exist (up to the caller to enforce that). The skiplist takes ownership</div><div class="line"> * of the passed SDS string 'ele'. */</div><div class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</div><div class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];</div><div class="line">    <span class="keyword">int</span> i, level;</div><div class="line"></div><div class="line">    serverAssert(!isnan(score));</div><div class="line">    x = zsl-&gt;header;</div><div class="line">    <span class="comment">/*记录新节点应插入位置，即每一层的前后指向节点,便于关联节点后续更新指向*/</span></div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="comment">/* store rank that is crossed to reach the insert position */</span></div><div class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</div><div class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</div><div class="line">        &#123;</div><div class="line">            rank[i] += x-&gt;level[i].span;</div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        &#125;</div><div class="line">        update[i] = x;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* we assume the element is not already inside, since we allow duplicated</span></div><div class="line">     * scores, reinserting the same element should never happen since the</div><div class="line">     * caller of zslInsert() should test in the hash table if the element is</div><div class="line">     * already inside or not. */</div><div class="line">     <span class="comment">/*生成新节点的随机层数,详细函数见后续内容*/</span></div><div class="line">    level = zslRandomLevel();</div><div class="line">    <span class="comment">//如果随机生成层大于当前跳表层数，更新</span></div><div class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</div><div class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</div><div class="line">            rank[i] = <span class="number">0</span>;</div><div class="line">            update[i] = zsl-&gt;header;</div><div class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</div><div class="line">        &#125;</div><div class="line">        zsl-&gt;level = level;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//创建新节点</span></div><div class="line">    x = zslCreateNode(level,score,ele);</div><div class="line">    <span class="comment">//更新新节点的每一层,使之插入跳表</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123; </div><div class="line">        <span class="comment">//类似于单链表的节点插入步奏</span></div><div class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</div><div class="line">        update[i]-&gt;level[i].forward = x;</div><div class="line">        <span class="comment">//更新跨度</span></div><div class="line">        <span class="comment">/* update span covered by update[i] as x is inserted here */</span></div><div class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</div><div class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* increment span for untouched levels */</span></div><div class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</div><div class="line">        update[i]-&gt;level[i].span++;<span class="comment">//前一个节点其他未连层跨度加1</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//更新后向指针</span></div><div class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</div><div class="line">    <span class="comment">//如果是最后一个节点</span></div><div class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</div><div class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        zsl-&gt;tail = x;</div><div class="line">    <span class="comment">//跳表节点数加1</span></div><div class="line">    zsl-&gt;length++;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Returns a random level for the new skiplist node we are going to create.</span></div><div class="line"> * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL</div><div class="line"> * (both inclusive), with a powerlaw-alike distribution where higher</div><div class="line"> * levels are less likely to be returned. */</div><div class="line">/ <span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_P 0.25      <span class="comment">/* Skiplist P = 1/4 */</span></span></div><div class="line"><span class="comment">/*random返回0-2^32-1的一个32位整数,循环的大概意思是每次以四分之一的概率level+1,最终得到一个小于最大层数的值*/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>)) <span class="comment">//后面的值16383.75</span></div><div class="line">        level += <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="查找函数"><a href="#查找函数" class="headerlink" title="查找函数"></a>查找函数</h2><p>查询指定范围的第一个元素<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Find the first node that is contained in the specified range.</span></div><div class="line"> * Returns NULL when no element is contained in the range. */</div><div class="line"><span class="function">zskiplistNode *<span class="title">zslFirstInRange</span><span class="params">(zskiplist *zsl, zrangespec *range)</span> </span>&#123;</div><div class="line">    zskiplistNode *x;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="comment">/* If everything is out of range, return early. */</span></div><div class="line">    <span class="keyword">if</span> (!zslIsInRange(zsl,range)) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    x = zsl-&gt;header;</div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="comment">/* Go forward while *OUT* of range. */</span></div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</div><div class="line">            !zslValueGteMin(x-&gt;level[i].forward-&gt;score,range))</div><div class="line">                x = x-&gt;level[i].forward;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* This is an inner range, so the next node cannot be NULL. */</span></div><div class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</div><div class="line">    serverAssert(x != <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* Check if score &lt;= max. */</span></div><div class="line">    <span class="keyword">if</span> (!zslValueLteMax(x-&gt;score,range)) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslValueGteMin</span><span class="params">(<span class="keyword">double</span> value, zrangespec *spec)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> spec-&gt;minex ? (value &gt; spec-&gt;min) : (value &gt;= spec-&gt;min);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslValueLteMax</span><span class="params">(<span class="keyword">double</span> value, zrangespec *spec)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> spec-&gt;maxex ? (value &lt; spec-&gt;max) : (value &lt;= spec-&gt;max);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Returns if there is a part of the zset is in range. */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslIsInRange</span><span class="params">(zskiplist *zsl, zrangespec *range)</span> </span>&#123;</div><div class="line">    zskiplistNode *x;</div><div class="line"></div><div class="line">    <span class="comment">/* Test for ranges that will always be empty. */</span></div><div class="line">    <span class="keyword">if</span> (range-&gt;min &gt; range-&gt;max ||</div><div class="line">            (range-&gt;min == range-&gt;max &amp;&amp; (range-&gt;minex || range-&gt;maxex)))</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    x = zsl-&gt;tail;</div><div class="line">    <span class="keyword">if</span> (x == <span class="literal">NULL</span> || !zslValueGteMin(x-&gt;score,range))</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    x = zsl-&gt;header-&gt;level[<span class="number">0</span>].forward;</div><div class="line">    <span class="keyword">if</span> (x == <span class="literal">NULL</span> || !zslValueLteMax(x-&gt;score,range))</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">``` </div><div class="line"></div><div class="line"></div><div class="line">``` C</div><div class="line"><span class="comment">/* Struct to hold a inclusive/exclusive range spec by score comparison. */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">double</span> min, max;</div><div class="line">    <span class="keyword">int</span> minex, maxex; <span class="comment">/* are min or max exclusive? */</span></div><div class="line">&#125; zrangespec;</div><div class="line"></div><div class="line"><span class="comment">/* Struct to hold an inclusive/exclusive range spec by lexicographic comparison. */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    sds min, max;     <span class="comment">/* May be set to shared.(minstring|maxstring) */</span></div><div class="line">    <span class="keyword">int</span> minex, maxex; <span class="comment">/* are min or max exclusive? */</span></div><div class="line">&#125; zlexrangespec;</div></pre></td></tr></table></figure></p>
<h3 id="并行编程结构分析"><a href="#并行编程结构分析" class="headerlink" title="并行编程结构分析"></a>并行编程结构分析</h3><p>红黑树在更新的时候牵涉较广范围的节点，其更新不能充分利用局部特性<br>红黑树在内存与cache共享写数据与同步的代价高<br>红黑树在顺序加锁上很难想单链表那样保证正确<br>设计数据结构在并行编程性能特性分析有两点：</p>
<blockquote>
<p>第一：在并行编程方面,其性能应该考虑允许多线程在同一时间访问数据<br>第二：在并行硬件方面，最小化内存同步的代价<br>设计一个好的数据结构能够让不同的线程可以同时访问不同部分数据，并避免大的潜在的内存同步带来的开销</p>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote>
<p>《redis设计与实现》<br><a href="http://blog.csdn.net/daniel_ustc/article/details/20218489?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">http://blog.csdn.net/daniel_ustc/article/details/20218489?utm_source=tuicool&amp;utm_medium=referral</a><br><a href="http://www.drdobbs.com/parallel/choose-concurrency-friendly-data-structu/208801371?pgno=3" target="_blank" rel="external">http://www.drdobbs.com/parallel/choose-concurrency-friendly-data-structu/208801371?pgno=3</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/18/程序性能优化/" itemprop="url">
                  程序性能优化方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-18T20:20:59+08:00" content="2016-07-18">
              2016-07-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/性能优化/" itemprop="url" rel="index">
                    <span itemprop="name">性能优化</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/18/程序性能优化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/18/程序性能优化/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="程序性能优化"><a href="#程序性能优化" class="headerlink" title="程序性能优化"></a>程序性能优化</h1><p> 在深入理解os这本书中，在里面有一章是专门针对性能优化的，在高并发的系统中，程序性能直接关系到用户体验，一般来说用户容忍度总是非常低的，比如打开网页要求2s得到相应。</p>
<h2 id="是否可优化"><a href="#是否可优化" class="headerlink" title="是否可优化"></a>是否可优化</h2><p>思考<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *xp, <span class="keyword">int</span> *yp)</span></span>&#123;</div><div class="line">	*xp = *xp + *yp;</div><div class="line">	*yp = *xp - *yp;</div><div class="line">	*xp = *xp - *yp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可否替换为<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *xp, <span class="keyword">int</span> *yp)</span></span>&#123;</div><div class="line">    *xp = *xp + *yp;</div><div class="line">    *yp = *xp - *yp;</div><div class="line">    *xp = *xp - *yp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>又如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">twiddle</span><span class="params">(<span class="keyword">int</span> *xp, <span class="keyword">int</span> *yp)</span> </span>&#123;</div><div class="line">	*xp += *yp;</div><div class="line">    *xp += *yp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可否替换为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">twiddle1</span><span class="params">(<span class="keyword">int</span> *xp, <span class="keyword">int</span> *yp)</span> </span>&#123;</div><div class="line">*xp = <span class="number">2</span>* (*yp);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实际上上面连个看起来是传进来了不同的参数，但是当参数相同的话，结果是不一样的，优化是错的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> f() + f() + f();&#125;</div></pre></td></tr></table></figure></p>
<p>可否替换为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">3</span>*f();&#125;</div></pre></td></tr></table></figure></p>
<p>这种情况下，当f调用了全局变量就会产生副作用，返回值也可能会不一样</p>
<h2 id="常用的优化方法"><a href="#常用的优化方法" class="headerlink" title="常用的优化方法"></a>常用的优化方法</h2><h3 id="1-在循环中减少函数调用"><a href="#1-在循环中减少函数调用" class="headerlink" title="1.在循环中减少函数调用"></a><strong>1.在循环中减少函数调用</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Implementation of library function strlen */</span></div><div class="line"> <span class="comment">/* Compute length of string */</span></div><div class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span> *s)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> length = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span> (*s != ’\<span class="number">0</span>’) &#123;</div><div class="line">		s++;</div><div class="line">		length++;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> length;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lower1</span><span class="params">(<span class="keyword">char</span> *s)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)&#123;</div><div class="line">		<span class="keyword">if</span> (s[i] &gt;= ’A’ &amp;&amp; s[i] &lt;= ’Z’)</div><div class="line">		s[i] -= (’A’ - ’a’);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将strlen(s)从循环中外提</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lower1</span><span class="params">(<span class="keyword">char</span> *s)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(s); <span class="comment">//循环中调用外提</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)&#123;</div><div class="line">		<span class="keyword">if</span> (s[i] &gt;= ’A’ &amp;&amp; s[i] &lt;= ’Z’)</div><div class="line">		s[i] -= (’A’ - ’a’);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-消除不必要的存储器引用"><a href="#2-消除不必要的存储器引用" class="headerlink" title="2.消除不必要的存储器引用"></a><strong>2.消除不必要的存储器引用</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine</span><span class="params">(vec_ptr v, <span class="keyword">data_t</span> *dest)</span></span></div><div class="line"> &#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">int</span> length = vec_length(v); </div><div class="line">	*dest = IDENT; </div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">		<span class="keyword">data_t</span> val;</div><div class="line">		get_vec_element(v, i, &amp;val);</div><div class="line">		*dest = *dest OPER val;  </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在每次循环中减少中间过程读写<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Accumulate result in local variable */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine4</span><span class="params">(vec_ptr v, <span class="keyword">data_t</span> *dest)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">int</span> length = vec_length(v);</div><div class="line">	<span class="keyword">data_t</span> *data = get_vec_start(v); <span class="comment">//</span></div><div class="line">	<span class="keyword">data_t</span> x = IDENT;</div><div class="line">	*dest = IDENT;</div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">		x = x OPER data[i]; <span class="comment">//循环内相除存储器引用</span></div><div class="line">	&#125;</div><div class="line">	*dest = x;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-循环展开"><a href="#3-循环展开" class="headerlink" title="3.循环展开"></a><strong>3.循环展开</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">vsum1</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">    c[i] = a[i] + b[i];</div><div class="line"> &#125;</div><div class="line">循环展开为</div><div class="line">``` C++</div><div class="line"><span class="comment">/* Sum vector of n elements (n must be even) */</span></div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">vsum2</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line"> &#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i+=<span class="number">2</span>) &#123;</div><div class="line">         <span class="comment">/* Compute two elements per iteration */</span></div><div class="line">        c[i] = a[i] + b[i];</div><div class="line">        c[i+<span class="number">1</span>] = a[i+<span class="number">1</span>] + b[i+<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="4-提高并行性"><a href="#4-提高并行性" class="headerlink" title="4.提高并行性"></a><strong>4.提高并行性</strong></h3><p>使用多个临时变量，只在必要的时候将多个临时变量合并</p>
<h3 id="5-重新结合变换"><a href="#5-重新结合变换" class="headerlink" title="5.重新结合变换"></a><strong>5.重新结合变换</strong></h3><p>acc = (acc OP data[i]) OP data[i+1];<br>每次迭代都要求前一次迭代必须结束才能开始，因为第一个操作就要求读取acc的值．<br>acc = acc OP (data[i] OP data[i+1]);<br>修改后，下一次迭代的开始可以先于当前迭代的结束，因为下一次迭代可以先计算data[i] OP data[i+1]这个操作．</p>
<h2 id="阿姆达尔定律"><a href="#阿姆达尔定律" class="headerlink" title="阿姆达尔定律"></a>阿姆达尔定律</h2><p>阿姆达尔定律是计算机系统设计的重要定量原理之一，于1967年由IBM360系列机的主要设计者阿姆达尔首先提出。该定律是指：系统中对某一部件采用更快执行方式所能获得的系统性能改进程度，取决于这种执行方式被使用的频率，或所占总执行时间的比例。阿姆达尔定律实际上定义了采取增强（加速）某部分功能处理的措施后可获得的性能改进或执行时间的加速比。简单来说是通过更快的处理器来获得加速是由慢的系统组件所限制。<br>阿姆达尔曾致力于并行处理系统的研究。对于固定负载情况下描述并行处理效果的加速比s，阿姆达尔经过深入研究给出了如下公式：<br>$$S=1/(1-a+a/n)$$<br>其中，a为并行计算部分所占比例，n为并行处理结点个数。这样，当1-a=0时，(即没有串行，只有并行)最大加速比s=n；当a=0时（即只有串行，没有并行），最小加速比s=1；当n→∞时，极限加速比s→ 1/（1-a），这也就是加速比的上限。例如，若串行代码占整个代码的25%，则并行处理的总体性能不可能超过4。这一公式已被学术界所接受，并被称做“阿姆达尔定律”，也称为“安达尔定理”(Amdahl law)。</p>
<h2 id="C-C-中的优化"><a href="#C-C-中的优化" class="headerlink" title="C/C++中的优化"></a>C/C++中的优化</h2><blockquote>
<ul>
<li><strong>如字符串初始化使用 str[‘\0’] (避免使用memeset)</strong></li>
<li><strong>char buffer[1024] = {100} 会调用memset, 可以改为:</strong><br>char buffer[1024];<br>buffer[0] = 100</li>
<li><strong>选择正确的数据结构，正确选择stl的容器</strong><ul>
<li>数据量大时可以使用std::str1 或boost中 unordered_set/map 替代<br>map/set, 前者基于hash实现, 后者基于rb tree实现</li>
<li>std::list 求长度 O(n)</li>
<li>STL 的容器用完或者使用前记得reset, 否则会膨胀, 类似内存泄漏<br>reset 并没真正释放内存, 可能只是修改了长度和指针位置</li>
<li>尽量使用std::sort, 而不是自写排序</li>
<li>使用reverse 避免不必要的内存重分配</li>
<li>去重和查找尽量用hashmap 而不是 vector + find</li>
</ul>
</li>
<li><strong>避免重复申请内存</strong><ul>
<li>用可重复初始化对象, 代替每次都new</li>
<li>重复多次申请小块内存, 可以自己实现简单的buffer管理器</li>
<li>使用tcmalloc ?</li>
</ul>
</li>
<li><strong>多线程</strong><ul>
<li>多线程的调度, 让 IO 和 CPU计算 相互重叠，降低<br>latency</li>
<li>能提高绝对性能, 但是平均性能提升明显</li>
</ul>
</li>
<li><strong>openmp让循环中可以并行的部分得到并行处理</strong><ul>
<li>o 打开编译选项 -fopenmp</li>
</ul>
</li>
<li><strong>按字节固定初始有时可使用memeset,比for循环快很多</strong><ul>
<li>测试过1亿字符串统一赋值，用memeset比for循环赋值快10倍</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>&lt;&lt;深入理解操作系统&gt;&gt;<br>&lt;&lt;大牛分享&gt;&gt;</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/16/redis持久化之AOF&RDB/" itemprop="url">
                  redis持久化之RDB与AOF
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-16T13:38:59+08:00" content="2016-07-16">
              2016-07-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Redis学习/" itemprop="url" rel="index">
                    <span itemprop="name">Redis学习</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/16/redis持久化之AOF&RDB/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/16/redis持久化之AOF&RDB/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道redis是内存数据库，如果不将数据库转态(当前服务器非空数据库以及键值对)保存在内存中,就得保存在磁盘里，否则一旦服务器退出，服务器中的数据库转态也会消失<br>为了解决这个问题，redis采用了两种持久化方式，一种为RDB，一种为AOF</p>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>rdb方式就是手动或者配置定期化将数据库以及键值对保存到一个RDB文件中，称之为RDB持久化，这里需要了解的是:</p>
<div align="center"><br><img src="/img/rdb.jpg"><br></div>

<h3 id="RDB如何是如何创建的，执行SAVE或者BGSAVE的流程"><a href="#RDB如何是如何创建的，执行SAVE或者BGSAVE的流程" class="headerlink" title="RDB如何是如何创建的，执行SAVE或者BGSAVE的流程"></a>RDB如何是如何创建的，执行SAVE或者BGSAVE的流程</h3><p>BGSAVE主要的实现是利用fork()创建一个子进程，保存工作由子进程执行，所以子进程在创建子进程的过程中，Redis服务器仍然可以响应客户端请求而不会阻塞，但是在BGSAVE的过程中，拒绝BGSAVE,SAVE执行，BGREWRITEAOF延迟执行，主要为了避免竞争。<br>子进程：fork()-&gt;rdbsave(…)-&gt;_exit()||exit()<br>父进程：记录fork与子进程相关信息，输出日志，然后马上返回状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveBackground</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line">    <span class="keyword">pid_t</span> childpid;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) <span class="keyword">return</span> C_ERR;</div><div class="line"></div><div class="line">    server.dirty_before_bgsave = server.dirty;</div><div class="line">    server.lastbgsave_try = time(<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    start = ustime();</div><div class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123; </div><div class="line">        <span class="keyword">int</span> retval;</div><div class="line"></div><div class="line">        <span class="comment">/* Child */</span></div><div class="line">        closeListeningSockets(<span class="number">0</span>);</div><div class="line">        redisSetProcTitle(<span class="string">"redis-rdb-bgsave"</span>);</div><div class="line">        retval = rdbSave(filename);</div><div class="line">        <span class="keyword">if</span> (retval == C_OK) &#123;</div><div class="line">            <span class="keyword">size_t</span> private_dirty = zmalloc_get_private_dirty();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (private_dirty) &#123;</div><div class="line">                serverLog(LL_NOTICE,</div><div class="line">                    <span class="string">"RDB: %zu MB of memory used by copy-on-write"</span>,</div><div class="line">                    private_dirty/(<span class="number">1024</span>*<span class="number">1024</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        exitFromChild((retval == C_OK) ? <span class="number">0</span> : <span class="number">1</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/* Parent */</span></div><div class="line">        server.stat_fork_time = ustime()-start;</div><div class="line">        server.stat_fork_rate = (<span class="keyword">double</span>) zmalloc_used_memory() * <span class="number">1000000</span> / server.stat_fork_time / (<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>); <span class="comment">/* GB per second. */</span></div><div class="line">        latencyAddSampleIfNeeded(<span class="string">"fork"</span>,server.stat_fork_time/<span class="number">1000</span>);</div><div class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</div><div class="line">            server.lastbgsave_status = C_ERR;</div><div class="line">            serverLog(LL_WARNING,<span class="string">"Can't save in background: fork: %s"</span>,</div><div class="line">                strerror(errno));</div><div class="line">            <span class="keyword">return</span> C_ERR;</div><div class="line">        &#125;</div><div class="line">        serverLog(LL_NOTICE,<span class="string">"Background saving started by pid %d"</span>,childpid);</div><div class="line">        server.rdb_save_time_start = time(<span class="literal">NULL</span>);</div><div class="line">        server.rdb_child_pid = childpid;</div><div class="line">        server.rdb_child_type = RDB_CHILD_TYPE_DISK;</div><div class="line">        updateDictResizePolicy();</div><div class="line">        <span class="keyword">return</span> C_OK;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> C_OK; <span class="comment">/* unreached */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* After an RDB dump or AOF rewrite we exit from children using _exit() instead of</span></div><div class="line"> * exit(), because the latter may interact with the same file objects used by</div><div class="line"> * the parent process. However if we are testing the coverage normal exit() is</div><div class="line"> * used in order to obtain the right coverage information. */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">exitFromChild</span><span class="params">(<span class="keyword">int</span> retcode)</span> </span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COVERAGE_TEST</span></div><div class="line">    <span class="built_in">exit</span>(retcode);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="number">_</span><span class="built_in">exit</span>(retcode);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="如何定期保存"><a href="#如何定期保存" class="headerlink" title="如何定期保存"></a>如何定期保存</h3><p>服务器除了记录saveparam这样的结构体数组来保存用户自定义的多个保存条件<br>(在多少秒之内进行了多少次修改),还另外记录了dirty，即每一次执行一个数据库修改命令，程序对dirty计数加一，lastsave是上一次执行保存的时间，redis的服务器周期性函数servercron默认每隔100ms检查save选项所设置的保存条件是否满足</p>
<p>``` C<br>struct redisServer{<br>    /<em> RDB persistence </em>/<br>    long long dirty;                /<em> Changes to DB from the last save </em>/<br>    pid_t rdb_child_pid;            /<em> PID of RDB saving child </em>/<br>    struct saveparam <em>saveparams;   /</em> Save points array for RDB <em>/<br>    time_t lastsave;                /</em> Unix time of last successful save */</p>
<p>}</p>
<h3 id="RDB文件结构设计"><a href="#RDB文件结构设计" class="headerlink" title="RDB文件结构设计"></a>RDB文件结构设计</h3><p>RDB文件是一个经过压缩的二进制文件，由多个部分组成</p>
<div align="center"><br><img src="/img/rdbfile.jpg"><br></div>

<div align="center"><br><img src="/img/rdbfile1.jpg"><br></div>

<div align="center"><br><img src="/img/rdbfile2.jpg"><br></div><br>## AOF<br>RDB是通过保存数据库的键值对来记录数据库转态，而AOF(APPEND ONLY FILE)持久化则是通过保存redis服务器所执行的写命令来记录数据库转态的<br><div align="center"><br><img src="/img/aof.jpg"><br></div>

<h3 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a>实现要点</h3><p>未完待续</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote>
<p>《redis设计与实现》<br> redis github源码</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/11/网络爬虫总结/" itemprop="url">
                  爬虫总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-11T10:01:59+08:00" content="2016-07-11">
              2016-07-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/C-与linux网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">C++与linux网络编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/11/网络爬虫总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/11/网络爬虫总结/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在校期间由于到时I数据需求以及自己偶尔倒腾，写过一段时间爬虫，爬过csdn博客,天涯论坛,sina博客,sina微公益，学校就业系统数据(当时基本把全院就业数据爬下来了，包括每个人的身份证家庭住址联系方式就业去向等信息)等等,也爬过主流网站的信息当时想着做了一个粗糙的小型搜索引擎.在实习阶段写过一段时间爬虫系统，此时就主要用的scrapy框架了，爬取了7个主流手游网站游戏资讯论坛的信息.一直没有空去总结下,趁着有空总结下基本技巧</p>
<h2 id="关于爬取的三个方面"><a href="#关于爬取的三个方面" class="headerlink" title="关于爬取的三个方面"></a>关于爬取的三个方面</h2><h3 id="网络爬虫归根结底是如何拿到服务器数据"><a href="#网络爬虫归根结底是如何拿到服务器数据" class="headerlink" title="网络爬虫归根结底是如何拿到服务器数据"></a>网络爬虫归根结底是如何拿到服务器数据</h3><p>在你分析完目标站点的需要的数据之后,思考如何爬取过程自动化，一般站点的数据组织方式都是有规律，比如csdn会有一个所有博客的一个汇总存档页，如果你需要爬取所有的页面博客，你需要分析第1页到第n页的页面连接url规律,然后依次请求每页数据，得到每个页的几十个博客url，下层进行每个url的深入爬取。</p>
<h3 id="如果你写过爬虫-你会在拿数据的过程会遇到各种各样的问题，这里做一个罗列-总结下遇到的问题以及别人总结的一些问题"><a href="#如果你写过爬虫-你会在拿数据的过程会遇到各种各样的问题，这里做一个罗列-总结下遇到的问题以及别人总结的一些问题" class="headerlink" title="如果你写过爬虫,你会在拿数据的过程会遇到各种各样的问题，这里做一个罗列,总结下遇到的问题以及别人总结的一些问题"></a>如果你写过爬虫,你会在拿数据的过程会遇到各种各样的问题，这里做一个罗列,总结下遇到的问题以及别人总结的一些问题</h3><blockquote>
<p>数据是ajax请求的数据，请求方式不反应在链接上<br>数据在请求过程受到服务器频次限制,ip被封|频次限制<br>数据需要登录才能抓取数据<br>数据是js解析后才能拿到<br>部分网站不管你头部具体内容是什么，总是得到gzip后的内容<br>服务器加上了防盗链的限制<br>服务器加了限制，只让常见浏览器访问<br>url请求时加了编码信息<br>https以及http爬取<br>验证码问题<br>url如何判重<br>数据编码问题以及请求参数编码</p>
</blockquote>
<h3 id="大型搜索引擎爬取问题"><a href="#大型搜索引擎爬取问题" class="headerlink" title="大型搜索引擎爬取问题"></a>大型搜索引擎爬取问题</h3><blockquote>
<p>在真实的大型爬虫系统中(比如百度),如何保证保证覆盖率，更新率，实效性，有效性<br>标准：全、快、准、新<br>覆盖率：链接是否已发现，网页是否已抓取<br>更新率：网页发生变化或失效后是否最大限度地发现并更新<br>时效性：新网页（时效性较高的网页）产生或网页发生变化后，是否及时发现、抓取、更新。<br>有效性：可以分为抓取有效性和存储有效性。<br>1）抓取有效性：是指抓取流量中有多少是抓取了有价值的东西，对CHK来说就是得到了新的链接，对GET抓回来了能建库的网页就是有效的。<br>2）存储有效性：是指主要是指节省link库和网页库的空间。如果存储了大量低质量的那有效性就不高。</p>
</blockquote>
<h3 id="上面的问题的一些解决方法"><a href="#上面的问题的一些解决方法" class="headerlink" title="上面的问题的一些解决方法"></a>上面的问题的一些解决方法</h3><p><strong> 数据是ajax请求的数据，请求方式不反应在链接上</strong><br>打开浏览器解析，分析ajax的真实请求url的规律，分析请求参数，分析结果json<br>按照实际url和参数请求<br><strong> 数据在请求过程受到服务器频次限制,ip被封|频次限制 </strong><br>使用代理IP服务器,scrapy有一个专门IP代理池<br>再一个可以使用sleep限制程序降低爬取频次<br>技术做的特别好的，封的厉害的需要获取开发者权限,token之类的</p>
<p><strong> 数据需要登录才能抓取数据 </strong><br>使用import urllib.request<br>并用用字典封装post键值对作为open方法的参数，包括用户名密码等必要参数</p>
<p><strong> 数据是js解析后才能拿到 </strong><br>使用selenium、phantomjs等模拟浏览器引擎构建一个真实的浏览器执行JS<br>百度也是有专门的解析器sunflower的，Sunflower采用firefox浏览器的mozilla内核，本质上就是把firefox的必要部分组装起来，得到一个同浏览器比较相似的抓取器，能够得到页面在浏览器实际展现时候的完整数据。它能够像浏览器一样处理html页面，包括js，css，xmlrequest</p>
<p><strong> 部分网站不管你头部具体内容是什么，总是得到gzip后的内容</strong><br>使用import gzip相应方法解压,重点要知道是有得到压缩数据情况</p>
<p><strong> 服务器加上了防盗链的限制 </strong><br>某些站点有反盗链设置，其实就是检查你发送请求的header里面，referer站点是不是他自己，我们只要把headers的referer改成该网站即可<br><strong> 服务器加了限制，只让常见浏览器访问</strong><br>请求时加上浏览器头部，伪装成浏览器<br><strong> url请求时加了编码信息 </strong><br>使用urllib.quote(‘’)</p>
<p><strong> https以及http爬取 </strong><br>https是加密传输，其实用scrapy爬取并没什么不一样</p>
<p><strong> 验证码问题　</strong><br>图像识别？训练好相应图片验证码模型，不过有些事要计算或者推理的，比较难</p>
<p><strong> url如何判重 </strong><br>判重需要节省内存，一般使用布隆过滤器，在数学之美中有提到过</p>
<p><strong> 大型搜索引擎爬取问题 </strong><br>入职百度以来看了爬虫相关文档,发现设计考虑问题还是非常多的，有空再总结下<br>相关重要问题，不涉及具体实现</p>
<h3 id="拿到数据之后剩余的问题就是如何解析拿到想要的数据入库"><a href="#拿到数据之后剩余的问题就是如何解析拿到想要的数据入库" class="headerlink" title="拿到数据之后剩余的问题就是如何解析拿到想要的数据入库."></a>拿到数据之后剩余的问题就是如何解析拿到想要的数据入库.</h3><p>这里主要分为两块:<br><strong>首页如何提取html页面想要的信息</strong></p>
<p>解析html可以使用BeautifulSoup和xpath,有很多解析tag的方法,比起正则使用起来方便容易很多,常用的findall,find,find_next,find_parent,get_text()等等，这里不详细描述<br>参看官方文档,<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" target="_blank" rel="external">https://www.crummy.com/software/BeautifulSoup/bs4/doc/</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</div></pre></td></tr></table></figure></p>
<p>当然也可以自己实现,百度就是自己C实现了解析的基础库</p>
<p><strong>怎么存储</strong><br>数据量小可以直接按表格形式存入excel<br>推荐两个python包<br>import xlwt3<br>from xlrd import open_workbook<br>数据量大,使用mysql数据库或者本地文件</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/05/IO复用之-Select poll 和epoll/" itemprop="url">
                  linux I/O复用之-select epoll
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-05T01:01:59+08:00" content="2016-07-05">
              2016-07-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/C-与linux网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">C++与linux网络编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/05/IO复用之-Select poll 和epoll/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/05/IO复用之-Select poll 和epoll/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="I-O复用应用场景"><a href="#I-O复用应用场景" class="headerlink" title="I/O复用应用场景"></a>I/O复用应用场景</h2><blockquote>
<p>当客户同时处理多个描述符(交互式输入和网络套接字)<br>TCP服务器同时处理监听套接字和已连接套接字<br>既要处理TCP又要处理UDP<br>处理多个服务或者多个协议</p>
</blockquote>
<h2 id="五种I-O模型"><a href="#五种I-O模型" class="headerlink" title="五种I/O模型"></a>五种I/O模型</h2><p><strong>阻塞式I/O</strong></p>
<div align="center"><br><img src="/img/io1.jpg" alt="^_^||"><br></div>

<p><strong>阻塞式I/O</strong></p>
<div align="center"><br><img src="/img/io2.jpg" alt="^_^||"><br></div><br><strong>I/O复用</strong><br><div align="center"><br><img src="/img/io3.jpg" alt="^_^||"><br></div><br><strong>信号驱动式I/O</strong><br><div align="center"><br><img src="/img/io4.jpg" alt="^_^||"><br></div><br><strong>异步I/O</strong><br><div align="center"><br><img src="/img/io5.jpg" alt="^_^||"><br></div>

<h3 id="五种I-O模型总结"><a href="#五种I-O模型总结" class="headerlink" title="五种I/O模型总结"></a>五种I/O模型总结</h3><div align="center"><br><img src="/img/io-summary.jpg" alt="^_^||"><br></div>

<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>select的第一个参数为fdset集合中最大描述符值加1，select对应于内核中的sys_select调用，sys_select首先将第二三四个参数指向的fd_set拷贝到内核，然后对每个被SET的描述符进行poll，并记录在临时结果中(fdset)，如果有事件发生，select会将临时结果写到用户空间并返回，当轮询一遍后没有任何事件发生，如果指定了超时时间，则select会睡眠到超时，睡眠结束后再进行下一次轮询，并将临时结果写到用户空间，然后返回。select返回后，需要逐一检查关注的描述符是否被SET（事件是否发生）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, <span class="keyword">struct</span> timeval* timeout)</span></span>;</div></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">参数                  描述</div><div class="line">nfds             sets的文件描述符的最大值</div><div class="line">readfds          fd_set type 类型，只读的描述符集 </div><div class="line">writefds         fd_set type 类型，只写的描述符集 </div><div class="line">errorfds         fd_set type 类型，错误的描述符集 </div><div class="line">timeout          超时等待时间</div></pre></td></tr></table></figure>
<p>修改fd_set类型的参数，用到以下操作<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> fd_set</div><div class="line">&#123;</div><div class="line">    u_int fd_count;</div><div class="line">    <span class="keyword">int</span> fd_array[FD_SETSIZE];</div><div class="line">&#125;</div><div class="line"><span class="comment">//fd_array可SIZE*8个socket</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd,fd_set *fdset)</span></span>;</div><div class="line"><span class="comment">//返回值：若fd在描述符集中则返回非0值，否则返回0</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd,fd_set *fdset)</span></span>; <span class="comment">//fd指描述符</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd,fd_set *fdset)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;</div></pre></td></tr></table></figure></p>
<p>整体运行过程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> sock;</div><div class="line">FILE *fp;</div><div class="line"><span class="keyword">struct</span> fd_set fds;</div><div class="line"><span class="keyword">struct</span> timeval timeout=&#123;<span class="number">3</span>,<span class="number">0</span>&#125;; <span class="comment">//select等待3秒，3秒轮询，要非阻塞就置0</span></div><div class="line"><span class="keyword">char</span> buffer[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;; <span class="comment">//256字节的接收缓冲区</span></div><div class="line"><span class="comment">//假定已经建立UDP连接，具体过程不写，简单，当然TCP也同理，主机ip和port都已经给定，要写的文件已经打开</span></div><div class="line">sock=socket(...);</div><div class="line">bind(...);</div><div class="line">fp=fopen(...);</div><div class="line"><span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">    FD_ZERO(&amp;amp;fds); <span class="comment">//每次循环都要清空集合，否则不能检测描述符变化</span></div><div class="line">    FD_SET(sock,&amp;amp;fds); <span class="comment">//添加描述符</span></div><div class="line">    FD_SET(fp,&amp;amp;fds); <span class="comment">//同上</span></div><div class="line">    maxfdp=sock&amp;gt;fp?sock+<span class="number">1</span>:fp+<span class="number">1</span>; <span class="comment">//描述符最大值加1</span></div><div class="line">    <span class="comment">// for(int i =0 ;i &amp;lt; maxfds; i++) if(FD_ISSET()) &#123; &#125;</span></div><div class="line">    <span class="keyword">switch</span>(select(maxfdp,&amp;amp;fds,&amp;amp;fds,<span class="literal">NULL</span>,&amp;amp;timeout)) <span class="comment">//select使用</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">case</span> <span class="number">-1</span>: <span class="built_in">exit</span>(<span class="number">-1</span>);<span class="keyword">break</span>; <span class="comment">//select错误，退出程序</span></div><div class="line">        <span class="keyword">case</span> <span class="number">0</span>:<span class="keyword">break</span>; <span class="comment">//再次轮询</span></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">if</span>(FD_ISSET(sock,&amp;amp;fds)) <span class="comment">//测试sock是否可读，即是否网络上有数据</span></div><div class="line">            &#123;</div><div class="line">                recvfrom(sock,buffer,<span class="number">256</span>,.....);<span class="comment">//接受网络数据</span></div><div class="line">                <span class="keyword">if</span>(FD_ISSET(fp,&amp;amp;fds)) <span class="comment">//测试文件是否可写</span></div><div class="line">                fwrite(fp,buffer...);<span class="comment">//写入文件</span></div><div class="line"> ......</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll函数类似于 select，可用于任何类型的文件描述符，与 select 不同，poll不是为每个状态（可读性、可写性和异常状态）构造一个描述符集，而是构造一个pollfd 结构数组向内核传递需要关注的事件，故没有描述符个数的限制，每个数组元素指定一个描述符编号以及对其所关心的状态，pollfd中的events字段和revents字段分别用于标示关注的事件和发生的事件。</p>
<p>poll的实现机制与select类似，其对应内核中的sys_poll，只不过poll向内核传递pollfd数组，然后对pollfd中的每个描述符进行poll，poll返回后，需要对pollfd中的每个元素检查其revents值，来判断事件是否发生。</p>
<p>返回值：</p>
<p>-1：有错误产生<br>0：超时时间到，而且没有描述符有状态变化<br>大于0：有状态变化的描述符个数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd fdarray[],<span class="keyword">nfds_t</span> nfds,<span class="keyword">int</span> timeout)</span></span>;</div><div class="line"><span class="keyword">struct</span> pollfd&#123;</div><div class="line">    <span class="keyword">int</span> fd; <span class="comment">//需要检查的文件描述符</span></div><div class="line">    <span class="keyword">short</span> events; <span class="comment">//等待的需要测试事件</span></div><div class="line">    <span class="keyword">short</span> revents; <span class="comment">//实际发生了的事件，也就是返回结果</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>应将每个数组元素的events成员设置为下图所示的值。通过这些值告诉内核我们对该描述符关心的是什么。返回时，内核设置revents成员，以说明对于该描述符已经发生了什么事件。（注意，poll没有更改events成员，这与select不同，select修改其参数以指示哪一个描述符已准备好了。）</p>
<p>timeout == -1 永远等待。当所指定的描述符中的一个已准备好，或捕捉到一个信号时则返回。如果捕捉到一个信号，则poll返回-1，errno设置为EINTR timeout == 0 不等待 timeout &gt; 0 等待timeout毫秒，如果已超时但是还没有一个描述符准备好，则返回值是0。</p>
<p>运行流程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> pollfd fds[IN_FILES];</div><div class="line"><span class="keyword">char</span> buf[MAX_BUFFER_SIZE];</div><div class="line"><span class="keyword">int</span> i,res,real_read, maxfd;</div><div class="line">fds[<span class="number">0</span>].fd = <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>((fds[<span class="number">1</span>].fd=open(&amp;quot;data1&amp;quot;,O_RDONLY|O_NONBLOCK)) &amp;lt; <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,&amp;quot;open data1 error:%s&amp;quot;,strerror(errno));</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>((fds[<span class="number">2</span>].fd=open(&amp;quot;data2&amp;quot;,O_RDONLY|O_NONBLOCK)) &amp;lt; <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,&amp;quot;open data2 error:%s&amp;quot;,strerror(errno));</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &amp;lt; IN_FILES; i++)</div><div class="line">&#123;</div><div class="line">    fds[i].events = POLLIN;</div><div class="line">&#125;</div><div class="line"><span class="keyword">while</span>(fds[<span class="number">0</span>].events || fds[<span class="number">1</span>].events || fds[<span class="number">2</span>].events)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (poll(fds, IN_FILES, TIME_DELAY) &amp;lt;= <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(&amp;quot;Poll error\n&amp;quot;);</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&amp;lt; IN_FILES; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (fds[i].revents)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, MAX_BUFFER_SIZE);</div><div class="line">            real_read = read(fds[i].fd, buf, MAX_BUFFER_SIZE);</div><div class="line">            <span class="keyword">if</span> (real_read &amp;lt; <span class="number">0</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span> (errno != EAGAIN)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!real_read)</div><div class="line">            &#123;</div><div class="line">                close(fds[i].fd);</div><div class="line">                fds[i].events = <span class="number">0</span>;</div><div class="line">            ......</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll通过epoll_create创建一个用于epoll轮询的描述符，通过epoll_ctl添加/修改/删除事件，通过epoll_wait 检查事件，epoll_wait 的第二个参数用于存放结果。</p>
<p>epoll与select、poll不同，首先，其不用每次调用都向内核拷贝事件描述信息，在第一次调用后，事件信息就会与对应的epoll描述符关联起来。另外epoll不是通过轮询，而是通过在等待的描述符上注册回调函数，当事件发生时，回调函数负责把发生的事件存储在就绪事件链表中，最后写到用户空间。</p>
<p>epoll返回后，该参数指向的缓冲区中即为发生的事件，对缓冲区中每个元素进行处理即可，而不需要像poll、select那样进行轮询检查。</p>
<p>系统调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</div><div class="line"><span class="comment">/*</span></div><div class="line">epoll的事件注册函数，它与select()是在监听事件时告诉内核要监听什么类型的事件不同，而是在这里先注册要监听的事件类型。第一个参数是epoll_create()的返回值，第二个参数表示动作，用三个宏来表示：</div><div class="line">EPOLL_CTL_ADD：注册新的fd到epfd中；</div><div class="line">EPOLL_CTL_MOD：修改已经注册的fd的监听事件；</div><div class="line">EPOLL_CTL_DEL：从epfd中删除一个fd；</div><div class="line">第三个参数是需要监听的fd，第四个参数是告诉内核需要监听什么事。</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</div><div class="line"><span class="keyword">struct</span> epoll_event结构如下：</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</div><div class="line">    <span class="keyword">void</span> *ptr;</div><div class="line">    <span class="keyword">int</span> fd;</div><div class="line">    <span class="keyword">__uint32_t</span> u32;</div><div class="line">    <span class="keyword">__uint64_t</span> u64;</div><div class="line">&#125; <span class="keyword">epoll_data_t</span>;</div><div class="line"><span class="keyword">struct</span> epoll_event</div><div class="line">&#123;</div><div class="line">    <span class="keyword">__uint32_t</span> events; <span class="comment">//Epoll events</span></div><div class="line">    <span class="keyword">epoll_data_t</span> data; <span class="comment">//User data variable</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>events可以是以下几个宏的集合：<br>EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；<br>EPOLLOUT：表示对应的文件描述符可以写；<br>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；<br>EPOLLERR：表示对应的文件描述符发生错误；<br>EPOLLHUP：表示对应的文件描述符被挂断；<br>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。<br>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里<br>运行流程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &amp;lt; nfds; ++n) &#123;</div><div class="line">    <span class="keyword">if</span> (events[n].data.fd == listener) &#123; <span class="comment">// 如果是主socket的事件的话，则表示</span></div><div class="line">    <span class="comment">// 有新连接进入了，进行新连接的处理。</span></div><div class="line">    client = accept(listener, (<span class="keyword">struct</span> sockaddr *) &amp;amp;local, &amp;amp;addrlen);</div><div class="line">    <span class="keyword">if</span> (client &amp;lt; <span class="number">0</span>)&#123;</div><div class="line">    perror(&amp;quot;accept&amp;quot;);</div><div class="line">    <span class="keyword">continue</span>;</div><div class="line">&#125;</div><div class="line">setnonblocking(client); <span class="comment">// 将新连接置于非阻塞模式</span></div><div class="line">ev.events = EPOLLIN | EPOLLET; <span class="comment">// 并且将新连接也加入EPOLL的监听队列。</span></div><div class="line"><span class="comment">// 注意，这里的参数EPOLLIN | EPOLLET并没有设置对写socket的监听，</span></div><div class="line"><span class="comment">// 如果有写操作的话，这个时候epoll是不会返回事件的，如果要对写操作</span></div><div class="line"><span class="comment">// 也监听的话，应该是EPOLLIN | EPOLLOUT | EPOLLET</span></div><div class="line">ev.data.fd = client;</div><div class="line"><span class="keyword">if</span> (epoll_ctl(kdpfd, EPOLL_CTL_ADD, client, &amp;amp;ev) &amp;lt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// 设置好event之后，将这个新的event通过epoll_ctl加入到epoll的监听队列里面，</span></div><div class="line">    <span class="comment">// 这里用EPOLL_CTL_ADD来加一个新的epoll事件，通过EPOLL_CTL_DEL来减少一个</span></div><div class="line">    <span class="comment">// epoll事件，通过EPOLL_CTL_MOD来改变一个事件的监听方式。</span></div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, &amp;quot;epoll <span class="built_in">set</span> insertion error: fd=%d0, client);</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (event[n].events &amp;amp; EPOLLIN) &#123; <span class="comment">// 如果是已经连接的用户，并且收到数据，</span></div><div class="line">    <span class="comment">// 那么进行读入</span></div><div class="line">    <span class="keyword">int</span> sockfd_r;</div><div class="line">    <span class="keyword">if</span> ((sockfd_r = event[n].data.fd) &amp;lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    read(sockfd_r, buffer, MAXSIZE);</div><div class="line">    <span class="comment">// 修改sockfd_r上要处理的事件为EPOLLOUT</span></div><div class="line">    ev.data.fd = sockfd_r;</div><div class="line">    ev.events = EPOLLOUT | EPOLLET;</div><div class="line">    epoll_ctl(epfd, EPOLL_CTL_MOD, sockfd_r, &amp;amp;ev)</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (event[n].events &amp;amp; EPOLLOUT) &#123; <span class="comment">// 如果有数据发送</span></div><div class="line">    <span class="keyword">int</span> sockfd_w = events[n].data.fd;</div><div class="line">    write(sockfd_w, buffer, <span class="keyword">sizeof</span>(buffer));</div><div class="line">    <span class="comment">// 修改sockfd_w上要处理的事件为EPOLLIN</span></div><div class="line">    ev.data.fd = sockfd_w;</div><div class="line">    ev.events = EPOLLIN | EPOLLET;</div><div class="line">    epoll_ctl(epfd, EPOLL_CTL_MOD, sockfd_r, &amp;amp;ev)</div><div class="line">&#125;</div><div class="line">    do_use_fd(events[n].data.fd);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>《UNIX环境高级编程》<br>《UNIX网络编程I卷》<br> <a href="http://armsword.com/2014/03/07/linux-io-multiplexing/" target="_blank" rel="external">http://armsword.com/2014/03/07/linux-io-multiplexing/</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/03/并发编程-多进程-IO复用-多线程/" itemprop="url">
                  并发编程之-多进程-I/O复用-多线程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-03T10:01:59+08:00" content="2016-07-03">
              2016-07-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/C-与linux网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">C++与linux网络编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/03/并发编程-多进程-IO复用-多线程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/03/并发编程-多进程-IO复用-多线程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自从入职百度以来，一直很忙，工作时间一直没有时间写博客，趁着周末又把深入理解操作系统重要章节看了一遍，对了部分知识有了更加深刻的理解，书真是要常读常新，久置易忘。下面分析总结下这三种常见并发编程方式：</p>
<h2 id="多进程echo服务器"><a href="#多进程echo服务器" class="headerlink" title="多进程echo服务器"></a>多进程echo服务器</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span></span>;</div><div class="line"><span class="comment">//事件处理函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="number">0</span>, WNOHANG) &gt; <span class="number">0</span>)</div><div class="line">    ;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h3><ol>
<li>服务器端打开一个socket<br>whil0e循环主体：</li>
<li>接受来自客户端的连接,返回一个已连接套接字符</li>
<li>fork初始化一个子进程,子进程提供服务</li>
<li>父进程关闭连接描述符<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> listenfd, connfd, port;</div><div class="line">    <span class="keyword">socklen_t</span> clientlen=<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</div><div class="line">    <span class="keyword">struct</span> sockaddr_in clientaddr;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    port = atoi(argv[<span class="number">1</span>]);</div><div class="line">    <span class="comment">// 根据信号编号调用事件处理函数</span></div><div class="line">    Signal(SIGCHLD, sigchld_handler);<span class="comment">//用于回收子进程资源-避免僵尸进程</span></div><div class="line">    listenfd = Open_listenfd(port);</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        connfd = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);</div><div class="line">        <span class="keyword">if</span> (Fork() == <span class="number">0</span>) &#123; </div><div class="line">            Close(listenfd); <span class="comment">/* 子进程关闭监听描述符 */</span></div><div class="line">            echo(connfd);    <span class="comment">/* echo服务 */</span> </div><div class="line">            Close(connfd);   <span class="comment">/* 子进程关闭连接描述符 */</span> </div><div class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);         <span class="comment">/* 子进程退出 */</span></div><div class="line">        &#125;</div><div class="line">        Close(connfd); <span class="comment">/* 父进程关闭连接描述符-很重要! */</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="I-O复用echo服务器"><a href="#I-O复用echo服务器" class="headerlink" title="I/O复用echo服务器"></a>I/O复用echo服务器</h2><p>select函数处理类型为fd_set的描述符集合，逻辑上把描述符集合看出换一个大小为n的位向量，select有两个输入，一个是读集合的描述符集合和该集合的基数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"csapp.h"</span></span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123; <span class="comment">/* 连接描述符池*/</span> </div><div class="line">    <span class="keyword">int</span> maxfd;        <span class="comment">/* 读集合的最大描述符 */</span>   </div><div class="line">    fd_set read_set;  <span class="comment">/* 所有活动描述符集合*/</span></div><div class="line">    fd_set ready_set; <span class="comment">/* 准备好读的描述符子集  */</span></div><div class="line">    <span class="keyword">int</span> nready;       <span class="comment">/* 从select中准备好读的描述符数量 */</span>   </div><div class="line">    <span class="keyword">int</span> maxi;         <span class="comment">/* highwater index into client arra */</span></div><div class="line">    <span class="keyword">int</span> clientfd[FD_SETSIZE];    <span class="comment">/* 活动描述符集 */</span></div><div class="line">    <span class="keyword">rio_t</span> clientrio[FD_SETSIZE]; <span class="comment">/* 活动读缓冲区集合 */</span></div><div class="line">&#125; pool; </div><div class="line"><span class="comment">//初始化连接池</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_pool</span><span class="params">(<span class="keyword">int</span> listenfd, pool *p)</span></span>;</div><div class="line"><span class="comment">//往pool添加客户端连接符</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_client</span><span class="params">(<span class="keyword">int</span> connfd, pool *p)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_clients</span><span class="params">(pool *p)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">int</span> byte_cnt = <span class="number">0</span>; <span class="comment">/* 计算从服务器接收的总字节*/</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> listenfd, connfd, port; </div><div class="line">    <span class="keyword">socklen_t</span> clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</div><div class="line">    <span class="keyword">struct</span> sockaddr_in clientaddr;</div><div class="line">    <span class="keyword">static</span> pool pool; </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    port = atoi(argv[<span class="number">1</span>]);</div><div class="line"></div><div class="line">    listenfd = Open_listenfd(port);</div><div class="line">    init_pool(listenfd, &amp;pool); <span class="comment">//初始化连接描述符池</span></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">    <span class="comment">/* 使用select等待监听描述符上的连接请求或来自标准输入上的命令 */</span></div><div class="line">    pool.ready_set = pool.read_set;</div><div class="line">    pool.nready = Select(pool.maxfd+<span class="number">1</span>, &amp;pool.ready_set, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* 当监听描述符准备好时，添加一个新的客户端已连接描述符到连接池 */</span></div><div class="line">    <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;pool.ready_set)) &#123; </div><div class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen); </div><div class="line">        add_client(connfd, &amp;pool); </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/* 从每个准备好的已连接描述符回送一行文本内容 */</span> </div><div class="line">    check_clients(&amp;pool); </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="多线程echo服务器"><a href="#多线程echo服务器" class="headerlink" title="多线程echo服务器"></a>多线程echo服务器</h2><p>###重要的几点</p>
<blockquote>
<ul>
<li>while循环中为何要动态分配一个整型来存放已连接描述符?</li>
<li>thread中Pthread_detach？</li>
</ul>
</blockquote>
<p>1.如果使用引用，由于线程竞争将导致意外结果，试想如果在下一次连接到来，thread例程函数中当前描述符变成下一次连接描述符<br>2.我们知道线程默认情况下被创建成可结合的，为了避免存储器泄漏(其资源如栈等)，每个结合线程要么被其他线程显式的收回，要么使用thread_detach被分离，待其终止由系统自动释放其资源，这样对于web程序而言是好的，因为web服务器每收到一个web浏览器的连接请求都创建一个对等线程，每个连接由一个单独的线程处理，没必要等也不愿意等到每个对等线程终止</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"csapp.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> listenfd, *connfdp, port;</div><div class="line">    <span class="keyword">socklen_t</span> clientlen=<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</div><div class="line">    <span class="keyword">struct</span> sockaddr_in clientaddr;</div><div class="line">    <span class="keyword">pthread_t</span> tid; </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    port = atoi(argv[<span class="number">1</span>]);</div><div class="line"></div><div class="line">    listenfd = Open_listenfd(port);</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        connfdp = Malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">//想想为啥不直接在Pthread_create使用引用参数</span></div><div class="line">        *connfdp = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen); </div><div class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, connfdp);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 一个线程例程 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span> </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">int</span> connfd = *((<span class="keyword">int</span> *)vargp);</div><div class="line">    Pthread_detach(pthread_self()); <span class="comment">//很重要，线程分离后才能在终止时由系统自动释放</span></div><div class="line">    Free(vargp);                   </div><div class="line">    echo(connfd);</div><div class="line">    Close(connfd);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>##方法优劣总结</p>
<h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>对于在父子进程间共享状态信息，进程有一个很清晰的模型，共享文件表不共享用户地址空间，这是优点又是缺点，一个是独立不会覆盖另一个进程的虚拟存储器，消除了许多令人迷惑的错误，另一方面使得进程间共享转态信息变的困难，共享信息-&gt;得通过IPC实现，开销高</p>
<h3 id="I-O复用"><a href="#I-O复用" class="headerlink" title="I/O复用"></a>I/O复用</h3><p>I/O复用不等价于并发事件驱动程序，但可以作为其基础，在并发事件驱动中，流是因为某个事件而前进的，逻辑流模型=》转态机，一个转态机由一组状态，输入事件和转移构成。<br><strong>优点</strong>：</p>
<blockquote>
<p>给了码农更多对于程序行为的控制，比如编写一个事件驱动的并发服务器，为某些客户端提供他们需要的服务，基于多进程是很困难，（redis的事件处理基于I/O复用）<br>运行在的单一进程上下文中，每个逻辑流都能访问该进程的全部地址空间，使得在流之间共享数据变的容易-便于调试</p>
</blockquote>
<p><strong>缺点</strong>:<br>编码复杂，代码量大，随着并发粒度见笑，复杂性-上升迅速</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>结合上述两者的特性，在执行模型上既有着类似多进程的多线程内核自动调度，又有着I/O复用流享用的共享整个虚拟地址空间的整个内容<br>线程是运行在进程上下文中的逻辑流，线程由内核自动调度，每个线程有她自己的线程上下文，包括Thread ID,栈，栈指针，程序计数器，通用目的寄存器和条件码，共享进程的整个虚拟地址空间</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/13/redis基本数据结构设计总结/" itemprop="url">
                  redis基本数据结构总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-13T17:38:59+08:00" content="2016-06-13">
              2016-06-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Redis学习/" itemprop="url" rel="index">
                    <span itemprop="name">Redis学习</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/13/redis基本数据结构设计总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/13/redis基本数据结构设计总结/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 趁着周末时间又将redis基本数据结构设计有看了一遍,前面看过源码解析都忘的差不多了,真是需要多多总结才能深刻理解与应用,有空再自己试着用C++实现一遍,学习需要一个过程,了解(有个印象)-&gt;深刻理解(能够自己实现)-&gt;运用自如(知晓其优点与不足,根据实际应用选用与改造)</p>
<h2 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h2><div align="center"><br><img src="/img/sds.jpg"><br></div>


<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</div><div class="line"></div><div class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></div><div class="line"> * However is here to document the layout of type 5 SDS strings. */</div><div class="line"><span class="keyword">struct</span> <span class="number">__</span>attribute__ ((<span class="number">__</span>packed__)) sdshdr5 &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></div><div class="line">    <span class="keyword">char</span> buf[];</div><div class="line">&#125;;</div><div class="line"><span class="keyword">struct</span> <span class="number">__</span>attribute__ ((<span class="number">__</span>packed__)) sdshdr8 &#123;</div><div class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></div><div class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></div><div class="line">    <span class="keyword">char</span> buf[];</div><div class="line">&#125;;</div><div class="line"><span class="keyword">struct</span> <span class="number">__</span>attribute__ ((<span class="number">__</span>packed__)) sdshdr16 &#123;</div><div class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></div><div class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></div><div class="line">    <span class="keyword">char</span> buf[];</div><div class="line">&#125;;</div><div class="line"><span class="keyword">struct</span> <span class="number">__</span>attribute__ ((<span class="number">__</span>packed__)) sdshdr32 &#123;</div><div class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></div><div class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></div><div class="line">    <span class="keyword">char</span> buf[];</div><div class="line">&#125;;</div><div class="line"><span class="keyword">struct</span> <span class="number">__</span>attribute__ ((<span class="number">__</span>packed__)) sdshdr64 &#123;</div><div class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></div><div class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></div><div class="line">    <span class="keyword">char</span> buf[];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="关于-attribute-packed-的含义"><a href="#关于-attribute-packed-的含义" class="headerlink" title="关于 attribute ((packed)) 的含义"></a>关于 <strong>attribute</strong> ((<strong>packed</strong>)) 的含义</h3><p> <strong>attribute</strong> ((packed)) 的作用就是告诉编译器，取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐，是GCC特有的语法。这个功能是跟操作系统没关系，跟编译器有关，gcc编译器不是紧凑模式的。在windows下用vc的编译器也不是紧凑的，用tc的编译器就是紧凑的。例如：<br>在TC下：struct my{ char ch; int a;} sizeof(int)=2;sizeof(my)=3;（紧凑模式）<br>在GCC下：struct my{ char ch; int a;} sizeof(int)=4;sizeof(my)=8;（非紧凑模式）<br>在GCC下：struct my{ char ch; int a;}<strong>attrubte</strong> ((packed)) sizeof(int)=4;sizeof(my)=5</p>
<p> <strong>attribute</strong> ((packed)) 的作用就是告诉编译器，取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐，是GCC特有的语法。这个功能是跟操作系统没关系，跟编译器有关，gcc编译器不是紧凑模式的。在windows下用vc的编译器也不是紧凑的，用tc的编译器就是紧凑的。例如：<br>在TC下：struct my{ char ch; int a;} sizeof(int)=2;sizeof(my)=3;（紧凑模式）<br>在GCC下：struct my{ char ch; int a;} sizeof(int)=4;sizeof(my)=8;（非紧凑模式）<br>在GCC下：struct my{ char ch; int a;}<strong>attrubte</strong> ((packed)) sizeof(int)=4;sizeof(my)=5</p>
<h3 id="字符串设计的优点"><a href="#字符串设计的优点" class="headerlink" title="字符串设计的优点"></a>字符串设计的优点</h3><blockquote>
<p>兼容部分C风格串函数,可以使用strcat，strcasecmp来比较sds-&gt;buf与C风格字符串<br>常数复杂度获得字符串长度<br>杜绝缓存区溢出<br>减少修改字符串长度时所需的内存重分配次数(空间预分配，当需要扩展时，a.同时分配额外的未使用空间，比如使free与len一样 b.大于等于1MB，比如30MB,那么再分配1MB)<br>惰性空间释放,其实只要修改len和free的值即可<br>二进制安全(按len来判定就结尾,不会像C串碰到空格结束)</p>
</blockquote>
<h2 id="双端链表"><a href="#双端链表" class="headerlink" title="双端链表"></a>双端链表</h2><p>双端链表比较常见，和我们学过的基础链表没有很大区别</p>
<div align="center"><br><img src="/img/list.jpg"><br></div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Node, List, and Iterator are the only data structures used currently. */</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> listNode &#123;</div><div class="line">    <span class="keyword">struct</span> listNode *prev; <span class="comment">//前向指针</span></div><div class="line">    <span class="keyword">struct</span> listNode *next; <span class="comment">//后向指针</span></div><div class="line">    <span class="keyword">void</span> *value;</div><div class="line">&#125; listNode;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> listIter &#123;</div><div class="line">    listNode *next;</div><div class="line">    <span class="keyword">int</span> direction;</div><div class="line">&#125; listIter;</div><div class="line"><span class="comment">//结构体含首尾结构和基本操作函数</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">list</span> &#123;</div><div class="line">    listNode *head;</div><div class="line">    listNode *tail;</div><div class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</div><div class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</div><div class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</div><div class="line">&#125; <span class="built_in">list</span>;</div></pre></td></tr></table></figure>
<h3 id="redis实现的链表特性"><a href="#redis实现的链表特性" class="headerlink" title="redis实现的链表特性"></a>redis实现的链表特性</h3><blockquote>
<p>带有prev和next指针，获取前置和后置节点的复杂度都是O(1)<br>无环,表头的prev和表尾的next指向空<br>带表头指针和表尾指针，获取时间复杂度为O(1)<br>带链表长度计数器<br>多态,链表节点使用void*指针来保存节点值,所以链表可以通过dup，free,match保存不同类型的值</p>
</blockquote>
<h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><div align="center"><br><img src="/img/intset.jpg"><br></div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> intset&#123;</div><div class="line">    <span class="comment">//编码方式</span></div><div class="line">    <span class="keyword">uint32_t</span> encoding;</div><div class="line">    <span class="keyword">uint32_t</span> length;</div><div class="line">    <span class="keyword">int8_t</span> contents[];</div><div class="line">&#125; intset;</div></pre></td></tr></table></figure>
<p>当encoding为INTSET_ENC_INT16时候,contents为int16_t类型的数组<br>当encoding为INTSET_ENC_INT32时候,contents为int32_t类型的数组<br>当encoding为INTSET_ENC_INT64时候,contents为int64_t类型的数组</p>
<p>不支持降级操作</p>
<blockquote>
<p>整数集合是集合键的底层实现之一<br>整数集合的底层实现为数组，这个数组以有序,无重复的方式保存集合元素，在有需要时候，程序会根据新添加元素的类型，改变这个数组的类型<br>升级操作为整数集合带来了操作上的灵活性，并且尽可能的节约了内存<br>整数集合只支持升级操作，不支持降级操作</p>
</blockquote>
<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>当一个哈希键只包含少量健值对时，并且每个键值对的键和值要么是小整数值，要么就是长度较短的字符串，那么redis将压缩列表作为哈希健的底层实现</p>
<div align="center"><br><img src="/img/ziplist.jpg"><br></div><br>压缩列表节点的构成<br><div align="center"><br><img src="/img/ziplistnode.jpg"><br></div>

<h3 id="特点总结"><a href="#特点总结" class="headerlink" title="特点总结"></a>特点总结</h3><blockquote>
<p>压缩列表是一种为节约内存而开发的顺序型数据结构<br>压缩列表被用作列表键和哈希键的底层实现之一<br>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值<br>添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率不高</p>
</blockquote>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>参看另一篇博文<br><a href="https://xiegonghai.github.io/2016/04/09/redis%E4%B8%ADdict%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E5%93%88%E5%B8%8C%E6%96%B9%E6%B3%95/" target="_blank" rel="external">https://xiegonghai.github.io/2016/04/09/redis%E4%B8%ADdict%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E5%93%88%E5%B8%8C%E6%96%B9%E6%B3%95/</a></p>
<h2 id="skiplist基本实现"><a href="#skiplist基本实现" class="headerlink" title="skiplist基本实现"></a>skiplist基本实现</h2><p>参看另一篇我的另一篇博文<br><a href="https://xiegonghai.github.io/2016/07/29/redis%E4%B8%AD%E8%B7%B3%E8%A1%A8%E5%88%86%E6%9E%90(vs%E7%BA%A2%E9%BB%91%E6%A0%91)/" target="_blank" rel="external">https://xiegonghai.github.io/2016/07/29/redis%E4%B8%AD%E8%B7%B3%E8%A1%A8%E5%88%86%E6%9E%90(vs%E7%BA%A2%E9%BB%91%E6%A0%91)/</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote>
<p>《redis设计与实现》<br> redis github源码</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/11/布隆过滤器/" itemprop="url">
                  布隆过滤器浅谈
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-11T20:41:56+08:00" content="2016-06-11">
              2016-06-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Data-structure-and-Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Data structure and Algorithm</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/11/布隆过滤器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/11/布隆过滤器/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><h2 id="之前就阅读过数学之美，知道有这么个基础的算法，可是因为不常用到也就没当回事，最近重新看到它觉得很高大上，就想来mark下"><a href="#之前就阅读过数学之美，知道有这么个基础的算法，可是因为不常用到也就没当回事，最近重新看到它觉得很高大上，就想来mark下" class="headerlink" title="之前就阅读过数学之美，知道有这么个基础的算法，可是因为不常用到也就没当回事，最近重新看到它觉得很高大上，就想来mark下"></a>之前就阅读过数学之美，知道有这么个基础的算法，可是因为不常用到也就没当回事，最近重新看到它觉得很高大上，就想来mark下</h2><p>设计初衷：<br>（Bloom Filter）是由布隆（Burton Howard Bloom）在1970年提出的，不知道当时布隆为啥想到设计时究竟是碰到了啥问题，但这确实很有效<br><strong>来看下面的问题：<br>1.检查一个单词是否拼写正确-&gt;看它是否在已经字典中<br>2.网络爬虫-&gt;一个网址是否访问过<br>3.邮件过滤，建立那些发垃圾邮件的地址的黑名单</strong></p>
<p><strong>你可能会说哈希表不就行了吗，但在2,3的问题中，网页和垃圾邮件地址全球动不动便是几十亿那，哈希的存储效率也就50%左右</strong><br>    一亿Email（一个占16字节）约为1.6GB内存，要是几十亿个地址就几百GB，需要耗费很大代码<br>所以啊，能不能少花点内存来干这事：于是布隆过滤器来了，只要12.5%到25%的哈希表空间就能干这事，但是有点小错误，这个小错误概率太小就基本不担心了</p>
<p>工作原理：<br>一亿Email =&gt; 16亿二进制（bit)==2亿字节（哈希就是16亿字节了）</p>
<h3 id="1-先全部位清0，对每一个电子邮件地址X，用8个不同的随机数产生器（F1，F2，-F8-产生8个信息指纹（比如md5"><a href="#1-先全部位清0，对每一个电子邮件地址X，用8个不同的随机数产生器（F1，F2，-F8-产生8个信息指纹（比如md5" class="headerlink" title="1.先全部位清0，对每一个电子邮件地址X，用8个不同的随机数产生器（F1，F2，..F8)产生8个信息指纹（比如md5),"></a>1.先全部位清0，对每一个电子邮件地址X，用8个不同的随机数产生器（F1，F2，..F8)产生8个信息指纹（比如md5),</h3><p>###2.然后用一个统一的随机数产生器G把这8个信息指纹=&gt;8个自然数g1,g2,g3..,g8,这些位置上的位置为1</p>
<p>1亿个地址放入建好这个布隆过滤器</p>
<p>然后新来一个，同样处理，对应8个二进制位 t1,t2,…,t8<br>如果全为1，好的=&gt;判定位垃圾邮件</p>
<p>你会想了，这样靠谱不，万一把非垃圾邮件误判了咋办</p>
<p>我们来看看误判的概率：<br>先来算任何一个位被置为1的概率p，这样你可以简单的就知道<br>新来一个，有8个位，如果被误判了，此时这8个位全为1，其概率为$$p^8$$<br>我们来推到下一般的情况，假设有m个位，n个元素，有k个哈希函数，<br>针对单个元素插入来说：<br>$$任一个位被置为1的概率：1/m$$<br>$$K个函数都没有把它置为1：（1-1/m)^k$$<br>$$插入了那个元素依然没有被置为1：（1-1/m)^{kn}$$<br>$$反过来说，一个位被置为1：1-（1-1/m)^{kn}$$<br>同样的新来一个，要命中其概率为：<br>$1-[1-1/m]^{kn})^k 近似（1-e^{-kn/m})^k$<br>上次k=8,n/m=1/16,计算值大约在万分之五，误判率非常低，基本可容忍。*</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/11/一个小C++程序内存泄漏检测/" itemprop="url">
                  C++内存泄漏以及检测
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-11T01:01:59+08:00" content="2016-06-11">
              2016-06-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/C-与linux网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">C++与linux网络编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/11/一个小C++程序内存泄漏检测/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/11/一个小C++程序内存泄漏检测/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>c++一般采用malloc/free或new/delete来动态分配和释放内存<br>二者有何不同？malloc/free是C/C++语言的标准库函数，new/delete是C++的运算符<br>malloc/free以及new/delete一般是配对出现，如果malloc后没有free，或者new后没有delete都将造成内存泄漏</p>
<p>##一个小例子来说明内存泄漏<br>例子1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int *p = new int[100];</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们用valgrind工具来检测这段程序的内存泄漏情况</p>
<div align="center"><br><img src="/img/leak1.jpg" alt="^_^||"><br></div>


<p>例2 我们正确的进行释放<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int *p = new int[100];</div><div class="line">    delete []p;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们用valgrind工具来检测这段程序的内存泄漏情况</p>
<div align="center"><br><img src="/img/leak2.jpg" alt="^_^||"><br></div>


<p>例3 我们用delete p来代替delete []p;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int *p = new int[100];</div><div class="line">    delete p;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们用valgrind工具来检测这段程序的内存泄漏情况</p>
<div align="center"><br><img src="/img/leak3.jpg" alt="^_^||"><br></div>

<p>从valgrind上我们可以看到，delete p和delete []p都没有造成内存泄漏，进行了全部内存的释放<br>但对与delete p用法valgrind明显的抛出了free/delete不匹配的提醒<br>其实按照正常逻辑推理，应该delete p只是释放了首地址元素的内存，应该会造成内存泄漏，而事实上<br>两种方式并未造成内存泄漏，这里尚有些疑问。</p>
<h2 id="malloc-free-与-new-free-的比较"><a href="#malloc-free-与-new-free-的比较" class="headerlink" title="malloc/free 与 new/free 的比较"></a>malloc/free 与 new/free 的比较</h2><h3 id="各自用法"><a href="#各自用法" class="headerlink" title="各自用法"></a>各自用法</h3><p>函数malloc 的原型如下：<br>void <em> malloc(size_t size);<br>用malloc 申请一块长度为length 的整数类型的内存，程序如下：<br>int </em>p = (int <em>) malloc(sizeof(int) </em> length);<br>我们应当把注意力集中在两个要素上：“类型转换”和“sizeof”<br>1、malloc 返回值的类型是void <em>，所以在调用malloc 时要显式地进行类型转换，将void </em> 转换成所需要的指针类型。<br>2、 malloc 函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。</p>
<p>函数free 的原型如下：<br>void free( void * memblock );<br>为什么free 函数不象malloc 函数那样复杂呢？这是因为指针p 的类型以及它所指的内存的容量事先都是知道的，语句free(p)能正确地释放内存。如果p 是NULL 指针，那么free对p 无论操作多少次都不会出问题。如果p 不是NULL 指针，那么free 对p连续操作两次就会导致程序运行错误。</p>
<p>运算符new 使用起来要比函数malloc 简单得多，例如：<br>int <em>p1 = (int </em>)malloc(sizeof(int) <em> length);<br>int </em>p2 = new int[length];<br>这是因为new内置了sizeof、类型转换和类型安全检查功能。对于非内部数据类型的对象而言，new 在创建动态对象的同时完成了初始化工作。如果对象有多个构造函数，那么new 的语句也可以有多种形式。<br>如果用new 创建对象数组，那么只能使用对象的无参数构造函数。例如<br>Obj <em>objects = new Obj[100];       // 创建100 个动态对象<br>不能写成<br>(x)Obj </em>objects = new Obj<a href="1">100</a>;        // 创建100 个动态对象的同时赋初值1<br>在用delete 释放对象数组时，留意不要丢了符号‘[]’。例如<br>delete []objects; // 正确的用法<br>delete objects; // 错误的用法</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><blockquote>
<p>1.new自动计算需要分配的空间，而malloc需要手工计算字节数<br>2、new是类型安全的，而malloc不是，比如：<br>                 int<em> p = new float[2]; // 编译时指出错误<br>                 int</em> p = malloc(2*sizeof(float)); // 编译时无法指出错误<br>3.new operator 由两步构成，分别是 operator new 和 construct,operator new对应于malloc，但operator new可以重载，可以自定义内存分配策略，甚至不做内存分配，甚至分配到非内存设备上。而malloc无能为力<br>4.new将调用constructor，而malloc不能；delete将调用destructor，而free不能<br>5.malloc/free要库文件支持，new/delete则不要。 </p>
</blockquote>
<p><strong>malloc/free是C/C++语言的标准库函数，new/delete是C++的运算符。<br>对于用户自定义的对象而言，用maloc/free无法满足动态管理对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>valgrind的使用<br><a href="http://blog.csdn.net/justdoithai/article/details/52347676" target="_blank" rel="external">http://blog.csdn.net/justdoithai/article/details/52347676</a><br><a href="http://blog.csdn.net/hackbuteer1/article/details/6789164" target="_blank" rel="external">http://blog.csdn.net/hackbuteer1/article/details/6789164</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/10/字典树实现/" itemprop="url">
                  字典树实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-10T21:41:56+08:00" content="2016-06-10">
              2016-06-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Data-structure-and-Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Data structure and Algorithm</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/10/字典树实现/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/10/字典树实现/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Trie树，又称字典树，单词查找树或者前缀树，是一种用于快速检索的多叉树结构，如英文字母的字典树是一个26叉树，数字的字典树是一个10叉树。</p>
<h3 id="Trie树的基本性质可以归纳为："><a href="#Trie树的基本性质可以归纳为：" class="headerlink" title="Trie树的基本性质可以归纳为："></a>Trie树的基本性质可以归纳为：</h3><p>（1）根节点不包含字符，除根节点意外每个节点只包含一个字符。</p>
<p>（2）从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。</p>
<p>（3）每个节点的所有子节点包含的字符串不相同。</p>
<h3 id="Trie树复杂度分析"><a href="#Trie树复杂度分析" class="headerlink" title="Trie树复杂度分析"></a>Trie树复杂度分析</h3><p>（1） 插入、查找的时间复杂度均为O(N)，其中N为字符串长度。</p>
<p>（2） 空间复杂度是26^n级别的，非常庞大（可采用双数组实现改善）。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>Trie是一种非常简单高效的数据结构，但有大量的应用实例<br>1） 字符串检索<br>事先将已知的一些字符串（字典）的有关信息保存到trie树里，查找另外一些未知字符串是否出现过或者出现频率</p>
<p>举例：<br>@  给出N 个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词</p>
<p>@  给出一个词典，其中的单词为不良单词。单词均为小写字母。再给出一段文本，文本的每一行也由小写字母构成。判断文本中是否含有任何不良单词。例如，若rob是不良单词，那么文本problem含有不良单词</p>
<p>2）字符串最长公共前缀</p>
<p>Trie树利用多个字符串的公共前缀来节省存储空间，反之，当我们把大量字符串存储到一棵trie树上时，我们可以快速得到某些字符串的公共前缀</p>
<p>@ 给出N 个小写英文字母串，以及Q 个询问，即询问某两个串的最长公共前缀的长度是多少？</p>
<p>解决方案：首先对所有的串建立其对应的字母树。此时发现，对于两个串的最长公共前缀的长度即它们所在结点的公共祖先个数，于是，问题就转化为了离线（Offline）的最近公共祖先（Least Common Ancestor，简称LCA）问题</p>
<p>3）排序</p>
<p>Trie树是一棵多叉树，只要先序遍历整棵树，输出相应的字符串便是按字典序排序的结果</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxBranchNum = <span class="number">26</span>;<span class="comment">//如果区分大小写，可以扩展到52</span></div><div class="line"></div><div class="line"><span class="comment">/*定义trie树结点*/</span></div><div class="line"><span class="keyword">class</span> TrieNode</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">     <span class="keyword">char</span>* word; <span class="comment">//节点表示的单词</span></div><div class="line">     <span class="keyword">int</span> count;  <span class="comment">//单词出现的次数</span></div><div class="line">     TrieNode* nextBranch[MaxBranchNum];<span class="comment">//指向26个字符节点的指针</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">     TrieNode() : word(<span class="literal">NULL</span>),count(<span class="number">0</span>)</div><div class="line">     &#123;</div><div class="line">          <span class="built_in">memset</span>(nextBranch,<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(TrieNode*) * MaxBranchNum);</div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*定义类Trie*/</span></div><div class="line"><span class="keyword">class</span> Trie</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">     Trie();</div><div class="line">     ~Trie();</div><div class="line">     <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>;<span class="comment">//插入字符串str</span></div><div class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">Search</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str,<span class="keyword">int</span>&amp; count)</span></span>;<span class="comment">//查找字符串str，并返回出现的次数</span></div><div class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">Remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>;<span class="comment">//删除字符串str</span></div><div class="line">     <span class="function"><span class="keyword">void</span> <span class="title">PrintALL</span><span class="params">()</span></span>;<span class="comment">//打印trie树中所有的结点</span></div><div class="line">     <span class="function"><span class="keyword">void</span> <span class="title">PrintPre</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>;<span class="comment">//打印以str为前缀的单词</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">     TrieNode* pRoot;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">     <span class="function"><span class="keyword">void</span> <span class="title">Destory</span><span class="params">(TrieNode* pRoot)</span></span>;</div><div class="line">     <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(TrieNode* pRoot)</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Trie::Trie()</div><div class="line">&#123;</div><div class="line">     pRoot = <span class="keyword">new</span> TrieNode();<span class="comment">//注意字典树的根不存放字符</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">Trie::~Trie()</div><div class="line">&#123;</div><div class="line">     Destory(pRoot);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*插入一个单词*/</span></div><div class="line"><span class="keyword">void</span> Trie::Insert(<span class="keyword">const</span> <span class="keyword">char</span>* str)</div><div class="line">&#123;</div><div class="line">     assert(<span class="literal">NULL</span> != str);</div><div class="line">     <span class="keyword">int</span> index;</div><div class="line">     TrieNode* pLoc = pRoot;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;str[i];i++)</div><div class="line">     &#123;</div><div class="line">          index = str[i] - <span class="string">'a'</span>;<span class="comment">//如果区分大小写，可以扩展</span></div><div class="line"></div><div class="line">          <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; MaxBranchNum)<span class="comment">//不执行插入</span></div><div class="line">          &#123;</div><div class="line">               <span class="keyword">return</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (<span class="literal">NULL</span> == pLoc-&gt;nextBranch[index])<span class="comment">//该单词的前缀不存在，要生成该结点</span></div><div class="line">          &#123;</div><div class="line">               pLoc-&gt;nextBranch[index] = <span class="keyword">new</span> TrieNode();</div><div class="line">          &#125;</div><div class="line">          pLoc = pLoc-&gt;nextBranch[index];</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> (<span class="literal">NULL</span> != pLoc-&gt;word)<span class="comment">//单词已经出现过</span></div><div class="line">     &#123;</div><div class="line">          pLoc-&gt;count++;</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">else</span>    <span class="comment">//单词没有出现过，应该插入单词</span></div><div class="line">     &#123;</div><div class="line">          pLoc-&gt;count++;</div><div class="line">          pLoc-&gt;word = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</div><div class="line">          assert(<span class="literal">NULL</span> != pLoc-&gt;word);</div><div class="line">          <span class="built_in">strcpy</span>(pLoc-&gt;word,str);</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*查找一个单词，如果存在该单词，则返回其出现次数*/</span></div><div class="line"><span class="keyword">bool</span> Trie::Search(<span class="keyword">const</span> <span class="keyword">char</span>* str,<span class="keyword">int</span>&amp; count)</div><div class="line">&#123;</div><div class="line">     assert(str != <span class="literal">NULL</span>);</div><div class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">     <span class="keyword">int</span> index = <span class="number">-1</span>;;</div><div class="line">     TrieNode* pLoc = pRoot;</div><div class="line">     <span class="keyword">while</span>(pLoc &amp;&amp; *str)</div><div class="line">     &#123;</div><div class="line">          index = *str - <span class="string">'a'</span>;<span class="comment">//如果区分大小写，可以扩展</span></div><div class="line">          <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; MaxBranchNum)<span class="comment">//不是一个单词，不执行插入</span></div><div class="line">          &#123;</div><div class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          pLoc = pLoc-&gt;nextBranch[index];</div><div class="line">          str++;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> (pLoc &amp;&amp; pLoc-&gt;word)<span class="comment">//条件成立，找到该单词</span></div><div class="line">     &#123;</div><div class="line">          count = pLoc-&gt;count;</div><div class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">bool</span> Trie::Remove(<span class="keyword">const</span> <span class="keyword">char</span>* str)</div><div class="line">&#123;</div><div class="line">     assert(<span class="literal">NULL</span> != str);</div><div class="line">     <span class="keyword">int</span> index = <span class="number">-1</span>;;</div><div class="line">     TrieNode* pLoc = pRoot;</div><div class="line">     <span class="keyword">while</span>(pLoc &amp;&amp; *str)</div><div class="line">     &#123;</div><div class="line">          index = *str - <span class="string">'a'</span>;<span class="comment">//如果区分大小写，可以扩展</span></div><div class="line"></div><div class="line">          <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; MaxBranchNum)<span class="comment">//不是一个单词，不执行插入</span></div><div class="line">          &#123;</div><div class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          pLoc = pLoc-&gt;nextBranch[index];</div><div class="line">          str++;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> (pLoc &amp;&amp; pLoc-&gt; word)<span class="comment">//条件成立，找到该单词</span></div><div class="line">     &#123;</div><div class="line">          <span class="keyword">delete</span>[] pLoc-&gt;word;</div><div class="line">          pLoc-&gt;word = <span class="literal">NULL</span>;</div><div class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Trie::PrintALL()</div><div class="line">&#123;</div><div class="line">     Print(pRoot);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Trie::PrintPre(<span class="keyword">const</span> <span class="keyword">char</span>* str)</div><div class="line">&#123;</div><div class="line">     assert(str != <span class="literal">NULL</span>);</div><div class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">     <span class="keyword">int</span> index = <span class="number">-1</span>;;</div><div class="line">     TrieNode* pLoc = pRoot;</div><div class="line">     <span class="keyword">while</span>(pLoc &amp;&amp; *str)</div><div class="line">     &#123;</div><div class="line">          index = *str - <span class="string">'a'</span>;<span class="comment">//如果区分大小写，可以扩展</span></div><div class="line"></div><div class="line">          <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; MaxBranchNum)<span class="comment">//不是一个单词，不执行插入</span></div><div class="line">          &#123;</div><div class="line">               <span class="keyword">return</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          pLoc = pLoc-&gt;nextBranch[index];</div><div class="line">          str++;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> (pLoc)<span class="comment">//条件成立，找到该单词</span></div><div class="line">     &#123;</div><div class="line">          Print(pLoc);</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*按照字典顺序输出以pRoot为根的所有的单词*/</span></div><div class="line"><span class="keyword">void</span> Trie::Print(TrieNode* pRoot)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">if</span> (<span class="literal">NULL</span> == pRoot)</div><div class="line">     &#123;</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//输出单词</span></div><div class="line">     <span class="keyword">if</span> (<span class="literal">NULL</span> != pRoot-&gt;word)</div><div class="line">     &#123;</div><div class="line">          <span class="built_in">cout</span>&lt;&lt;pRoot-&gt;word&lt;&lt;<span class="string">" "</span>&lt;&lt;pRoot-&gt;count&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//递归处理分支</span></div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; MaxBranchNum;i++)</div><div class="line">     &#123;</div><div class="line">          Print(pRoot-&gt;nextBranch[i]);</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*销毁trie树*/</span></div><div class="line"><span class="keyword">void</span> Trie::Destory(TrieNode* pRoot)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">if</span> (<span class="literal">NULL</span> == pRoot)</div><div class="line">     &#123;</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; MaxBranchNum;i++)</div><div class="line">     &#123;</div><div class="line">          Destory(pRoot-&gt;nextBranch[i]);</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//销毁单词占得空间</span></div><div class="line">     <span class="keyword">if</span> (<span class="literal">NULL</span> != pRoot-&gt;word)</div><div class="line">     &#123;</div><div class="line">          <span class="keyword">delete</span> []pRoot-&gt;word;</div><div class="line">          pRoot-&gt;word = <span class="literal">NULL</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">delete</span> pRoot;<span class="comment">//销毁结点</span></div><div class="line">     pRoot = <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">     Trie t;</div><div class="line">     <span class="built_in">string</span> str;</div><div class="line">     <span class="comment">//int count = -1;</span></div><div class="line">     <span class="keyword">int</span> n,m,count;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</div><div class="line">    &#123;</div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</div><div class="line">          &#123;</div><div class="line">               <span class="built_in">cin</span>&gt;&gt;str;</div><div class="line">               t.Insert(str.c_str());</div><div class="line">          &#125;</div><div class="line">          <span class="built_in">cin</span>&gt;&gt;m;</div><div class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</div><div class="line">          &#123;</div><div class="line">               <span class="built_in">cin</span>&gt;&gt;str;</div><div class="line">               <span class="keyword">bool</span> isFind = t.Search(str.c_str(),count);</div><div class="line">               <span class="built_in">cout</span>&lt;&lt;<span class="string">"isfind:"</span>&lt;&lt;isFind&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">               <span class="keyword">if</span>(isFind)<span class="built_in">cout</span>&lt;&lt;count&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">               <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">          &#125;</div><div class="line">    &#125;</div><div class="line">     system(<span class="string">"pause"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/home.jpg"
               alt="xiegonghai" />
          <p class="site-author-name" itemprop="name">xiegonghai</p>
          <p class="site-description motion-element" itemprop="description">while(question)just thinking;</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">22</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/justdoithai" title="我的csdn博客" target="_blank">我的csdn博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.cplusplus.com/reference/algorithm" title="C++标准库" target="_blank">C++标准库</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://github.com/xiegonghai" title="我的github" target="_blank">我的github</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://net.pku.edu.cn/~yhf/linux_c/" title="linux_C函数" target="_blank">linux_C函数</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://man.linuxde.net/" title="linux命令" target="_blank">linux命令</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://tool.oschina.net/" title="Tools" target="_blank">Tools</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiegonghai</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"doit"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
